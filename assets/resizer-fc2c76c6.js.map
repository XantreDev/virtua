{"version":3,"file":"resizer-fc2c76c6.js","sources":["../../src/core/utils.ts","../../src/core/cache.ts","../../src/core/store.ts","../../src/react/useIsomorphicLayoutEffect.ts","../../src/react/useSyncExternalStore.ts","../../src/core/dom.ts","../../src/core/scroller.ts","../../src/react/utils.ts","../../src/react/useStatic.ts","../../src/core/resizer.ts"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const now = Date.now;\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const range = <T>(length: number, cb: (i: number) => T): T[] =>\n  Array.from({ length }, (_, i) => cb(i));\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: NodeJS.Timeout | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = setTimeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { exists, max, min, range } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _measuredOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n) => {\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._measuredOffsetIndex = min(index, cache._measuredOffsetIndex);\n};\n\nconst computeOffset = (\n  cache: Writeable<Cache>,\n  index: number,\n  isTotal?: boolean\n): number => {\n  if (!cache._length) return 0;\n  if (cache._measuredOffsetIndex >= index) {\n    if (isTotal) {\n      return cache._offsets[index]! + getItemSize(cache, index);\n    } else {\n      return cache._offsets[index]!;\n    }\n  }\n\n  let i = cache._measuredOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i <= index) {\n    cache._offsets[i] = top;\n    if (i === index && !isTotal) {\n      break;\n    }\n    top += getItemSize(cache, i);\n    i++;\n  }\n  // mark as measured\n  cache._measuredOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  return computeOffset(cache, cache._length - 1, true);\n};\n\nexport const computeStartOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  return computeOffset(cache, index);\n};\n\nconst findIndex = (cache: Cache, i: number, distance: number): number => {\n  let sum = 0;\n  if (distance >= 0) {\n    // search forward\n    while (i < cache._length - 1) {\n      const h = getItemSize(cache, i++);\n      if ((sum += h) >= distance) {\n        if (sum - h / 2 >= distance) {\n          i--;\n        }\n        break;\n      }\n    }\n  } else {\n    // search backward\n    while (i > 0) {\n      const h = getItemSize(cache, --i);\n      if ((sum -= h) <= distance) {\n        if (sum + h / 2 < distance) {\n          i++;\n        }\n        break;\n      }\n    }\n  }\n\n  return min(max(i, 0), cache._length - 1);\n};\n\nexport const findStartIndexWithOffset = (\n  cache: Cache,\n  offset: number,\n  prevStartIndex: number,\n  prevOffset: number\n): number => {\n  return findIndex(cache, prevStartIndex, offset - prevOffset);\n};\n\nexport const findEndIndex = findIndex;\n\nexport const hasUnmeasuredItemsInRange = (\n  cache: Cache,\n  startIndex: number,\n  endIndex: number\n): boolean => {\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (cache._sizes[i] === UNCACHED) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const resetCache = (\n  length: number,\n  itemSize: number,\n  cache?: Cache\n): Cache => {\n  return {\n    _defaultItemSize: itemSize,\n    _length: length,\n    _measuredOffsetIndex: cache\n      ? min(cache._measuredOffsetIndex, length - 1)\n      : 0,\n    _sizes: range(length, (i) => {\n      const size = cache && cache._sizes[i];\n      if (exists(size)) {\n        return size;\n      }\n      return UNCACHED;\n    }),\n    _offsets: range(length, (i) => {\n      if (i === 0) {\n        // first offset must be 0\n        return 0;\n      }\n      const offset = cache && cache._offsets[i];\n      if (exists(offset)) {\n        return offset;\n      }\n      return UNCACHED;\n    }),\n  };\n};\n","import {\n  findStartIndexWithOffset,\n  resetCache,\n  getItemSize,\n  computeTotalSize,\n  findEndIndex,\n  computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  hasUnmeasuredItemsInRange,\n} from \"./cache\";\nimport type { Writeable } from \"./types\";\nimport { max } from \"./utils\";\n\ntype ItemJump = [sizeDiff: number, index: number];\nexport type ScrollJump = Readonly<ItemJump[]>;\nexport type ItemResize = [index: number, size: number];\ntype ItemsRange = [startIndex: number, endIndex: number];\n\nexport const SCROLL_STOP = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\nexport const SCROLL_MANUAL = 3;\ntype ScrollDirection =\n  | typeof SCROLL_STOP\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP\n  | typeof SCROLL_MANUAL;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_WINDOW_RESIZE = 2;\nexport const ACTION_SCROLL = 3;\nexport const ACTION_MANUAL_SCROLL = 4;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_WINDOW_RESIZE, size: number]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, offset: number];\n\nexport type VirtualStore = {\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInRange(startIndex: number): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getScrollOffset(): number;\n  _getViewportSize(): number;\n  _getScrollSize(): number;\n  _getJump(): ScrollJump;\n  _isHorizontal(): boolean;\n  _isRtl(): boolean;\n  _getItemIndexForScrollTo(offset: number): number;\n  _waitForScrollDestinationItemsMeasured(): Promise<void>;\n  _subscribe(cb: () => void): () => void;\n  _update(...action: Actions): void;\n  _getScrollDirection(): ScrollDirection;\n  _setScrollDirection(direction: ScrollDirection): void;\n  _updateCacheLength(length: number): void;\n};\n\nexport const createVirtualStore = (\n  itemCount: number,\n  itemSize: number,\n  isHorizontal: boolean,\n  isRtl: boolean,\n  initialItemCount: number = 0,\n  onScrollStateChange: (scrolling: boolean) => void,\n  onScrollOffsetChange: (offset: number) => void\n): VirtualStore => {\n  let viewportSize = itemSize * max(initialItemCount - 1, 0);\n  let scrollOffset = 0;\n  let jump: ItemJump[] = [];\n  let cache = resetCache(itemCount, itemSize);\n  let scrollDirection: ScrollDirection = SCROLL_STOP;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n  let _scrollToQueue: [() => void, () => void] | undefined;\n\n  const subscribers = new Set<() => void>();\n\n  return {\n    _getRange() {\n      const [prevStartIndex, prevEndIndex] = _prevRange;\n      const prevOffset = computeStartOffset(\n        cache as Writeable<Cache>,\n        prevStartIndex\n      );\n      const start = findStartIndexWithOffset(\n        cache,\n        scrollOffset,\n        prevStartIndex,\n        prevOffset\n      );\n      const end = findEndIndex(cache, start, viewportSize);\n      if (prevStartIndex === start && prevEndIndex === end) {\n        return _prevRange;\n      }\n      return (_prevRange = [start, end]);\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInRange(startIndex) {\n      return hasUnmeasuredItemsInRange(\n        cache,\n        startIndex,\n        findEndIndex(cache, startIndex, viewportSize)\n      );\n    },\n    _getItemOffset(index) {\n      return computeStartOffset(cache as Writeable<Cache>, index);\n    },\n    _getItemSize(index) {\n      return getItemSize(cache, index);\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getScrollSize() {\n      return computeTotalSize(cache as Writeable<Cache>);\n    },\n    _getJump() {\n      return jump;\n    },\n    _isHorizontal() {\n      return isHorizontal;\n    },\n    _isRtl() {\n      return isRtl;\n    },\n    _getItemIndexForScrollTo(offset) {\n      return findStartIndexWithOffset(cache, offset, 0, 0);\n    },\n    _waitForScrollDestinationItemsMeasured() {\n      if (_scrollToQueue) {\n        // Cancel waiting scrollTo\n        _scrollToQueue[1]();\n      }\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      // For example, ResizeObserver may not fire when window is not visible.\n      return new Promise((resolve, reject) => {\n        _scrollToQueue = [\n          () => {\n            // HACK: It should be resolved in the next microtask that is after React's render\n            Promise.resolve().then(() => {\n              resolve();\n              _scrollToQueue = undefined;\n            });\n          },\n          reject,\n        ];\n      });\n    },\n    _subscribe(cb) {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    _update(type, payload) {\n      const mutated = ((): boolean => {\n        switch (type) {\n          case ACTION_ITEM_RESIZE: {\n            const updated = payload.filter(\n              ([index, size]) => cache._sizes[index] !== size\n            );\n            // Skip if all items are cached and not updated\n            if (!updated.length) {\n              return false;\n            }\n\n            const updatedJump: ItemJump[] = [];\n            updated.forEach(([index, size]) => {\n              updatedJump.push([size - getItemSize(cache, index), index]);\n              setItemSize(cache as Writeable<Cache>, index, size);\n            });\n            jump = updatedJump;\n            return true;\n          }\n          case ACTION_WINDOW_RESIZE: {\n            if (viewportSize === payload) {\n              return false;\n            }\n            viewportSize = payload;\n            return true;\n          }\n          case ACTION_SCROLL:\n          case ACTION_MANUAL_SCROLL: {\n            const prevOffset = scrollOffset;\n            return (scrollOffset = payload) !== prevOffset;\n          }\n        }\n      })();\n\n      if (mutated) {\n        subscribers.forEach((cb) => {\n          cb();\n        });\n\n        if (type === ACTION_SCROLL) {\n          onScrollOffsetChange(scrollOffset);\n        } else if (_scrollToQueue && type === ACTION_ITEM_RESIZE) {\n          _scrollToQueue[0]();\n        }\n      }\n    },\n    _getScrollDirection() {\n      return scrollDirection;\n    },\n    _setScrollDirection(dir) {\n      const prev = scrollDirection;\n      scrollDirection = dir;\n      if (scrollDirection === SCROLL_STOP) {\n        onScrollStateChange(false);\n      } else if (\n        prev === SCROLL_STOP &&\n        (scrollDirection === SCROLL_DOWN || scrollDirection === SCROLL_UP)\n      ) {\n        onScrollStateChange(true);\n      }\n    },\n    _updateCacheLength(length) {\n      // It's ok to be updated in render because states should be calculated consistently regardless cache length\n      if (cache._length === length) return;\n      cache = resetCache(length, itemSize, cache);\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { useSyncExternalStore as _useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nexport const useSyncExternalStore = <T>(\n  subscibe: (onStoreChange: () => void) => () => void,\n  getSnapShot: () => T\n): T => {\n  return _useSyncExternalStore(subscibe, getSnapShot, getSnapShot);\n};\n","import { once } from \"./utils\";\n\n// The scroll position may be negative value in rtl direction.\n// https://github.com/othree/jquery.rtl-scroll-type\nexport const hasNegativeOffsetInRtl = once((scrollable: HTMLElement) => {\n  const key = \"scrollLeft\";\n  const prev = scrollable[key];\n  scrollable[key] = 1;\n  // scrollLeft can be positive under some specific situations even if negative mode, so we use `<` for now.\n  const isNegative = scrollable[key] < 1;\n  scrollable[key] = prev;\n  return isNegative;\n});\n","import { hasNegativeOffsetInRtl } from \"./dom\";\nimport {\n  ACTION_SCROLL,\n  ACTION_MANUAL_SCROLL,\n  ScrollJump,\n  VirtualStore,\n  SCROLL_MANUAL,\n  SCROLL_STOP,\n  SCROLL_UP,\n  SCROLL_DOWN,\n} from \"./store\";\nimport { debounce, throttle, max, min } from \"./utils\";\n\nexport type Scroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _getActualScrollSize: () => number;\n  _scrollTo: (offset: number) => void;\n  _scrollToIndex: (index: number, count: number) => void;\n  _fixScrollJump: (jump: ScrollJump, startIndex: number) => void;\n};\n\nexport const createScroller = (\n  store: VirtualStore,\n  isJustResized: () => boolean\n): Scroller => {\n  let rootElement: HTMLElement | undefined;\n  const isHorizontal = store._isHorizontal();\n  const isRtl = store._isRtl();\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n\n  const getActualScrollSize = (): number => {\n    if (!rootElement) return 0;\n    // Use element's scrollHeight/scrollWidth instead of stored scrollSize.\n    // This is because stored size may differ from the actual size, for example when a new item is added and not yet measured.\n    return isHorizontal ? rootElement.scrollWidth : rootElement.scrollHeight;\n  };\n  const scrollTo = (offset: number, diff?: boolean) => {\n    if (!rootElement) return;\n    if (isHorizontal && isRtl) {\n      if (hasNegativeOffsetInRtl(rootElement)) {\n        offset *= -1;\n      }\n    }\n    if (diff) {\n      rootElement[scrollToKey] += offset;\n    } else {\n      rootElement[scrollToKey] = offset;\n      store._setScrollDirection(SCROLL_MANUAL);\n    }\n  };\n  const scrollManually = async (\n    index: number,\n    getCurrentOffset: () => number\n  ) => {\n    const getOffset = (): number => {\n      let offset = getCurrentOffset();\n      const scrollSize = getActualScrollSize();\n      const viewportSize = store._getViewportSize();\n      if (scrollSize - (offset + viewportSize) <= 0) {\n        // Adjust if the offset is over the end, to get correct startIndex.\n        offset = scrollSize - viewportSize;\n      }\n      return offset;\n    };\n\n    if (store._hasUnmeasuredItemsInRange(index)) {\n      do {\n        // In order to scroll to the correct position, mount the items and measure their sizes before scrolling.\n        store._update(ACTION_MANUAL_SCROLL, getOffset());\n        try {\n          // Wait for the scroll destination items to be measured.\n          await store._waitForScrollDestinationItemsMeasured();\n        } catch (e) {\n          // canceled\n          return;\n        }\n      } while (store._hasUnmeasuredItemsInRange(index));\n\n      // Scroll with the updated value\n      scrollTo(getOffset());\n    } else {\n      const offset = getOffset();\n      scrollTo(offset);\n      // Sync viewport to scroll destination\n      store._update(ACTION_MANUAL_SCROLL, offset);\n    }\n  };\n\n  const calcTotalJump = (jump: ScrollJump): number =>\n    jump.reduce((acc, [j]) => acc + j, 0);\n\n  return {\n    _initRoot(root) {\n      rootElement = root;\n\n      const syncViewportToScrollPosition = () => {\n        let offset = root[scrollToKey];\n        if (isHorizontal && isRtl) {\n          if (hasNegativeOffsetInRtl(root)) {\n            offset *= -1;\n          }\n        }\n        const prevOffset = store._getScrollOffset();\n        if (prevOffset === offset) {\n          return;\n        }\n        const scrollDirection = store._getScrollDirection();\n        // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n        // Scroll events are dispatched enough so it's ok to skip some of them.\n        const resized = isJustResized();\n        if (\n          (scrollDirection === SCROLL_STOP || !resized) &&\n          // Ignore until manual scrolling\n          scrollDirection !== SCROLL_MANUAL\n        ) {\n          store._setScrollDirection(\n            prevOffset > offset ? SCROLL_UP : SCROLL_DOWN\n          );\n        }\n        store._update(ACTION_SCROLL, offset);\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._setScrollDirection(SCROLL_STOP);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      // Infer scroll state also from wheel events\n      // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n      const onWheel = throttle((e: WheelEvent) => {\n        if (store._getScrollDirection() === SCROLL_STOP) {\n          // Scroll start should be detected with scroll event\n          return;\n        }\n        if (e.ctrlKey) {\n          // Probably a pinch-to-zoom gesture\n          return;\n        }\n        // Get delta before checking deltaMode for firefox behavior\n        // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n        if (isHorizontal ? e.deltaX : e.deltaY) {\n          const offset = store._getScrollOffset();\n          if (\n            offset > 0 &&\n            offset < store._getScrollSize() - store._getViewportSize()\n          ) {\n            onScrollStopped();\n          }\n        }\n      }, 50);\n\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _getActualScrollSize: getActualScrollSize,\n    _scrollTo(offset) {\n      offset = max(offset, 0);\n\n      scrollManually(store._getItemIndexForScrollTo(offset), () => offset);\n    },\n    _scrollToIndex(index, count) {\n      index = max(min(index, count - 1), 0);\n\n      scrollManually(index, () => store._getItemOffset(index));\n    },\n    _fixScrollJump: (jump, startIndex) => {\n      const scrollDirection = store._getScrollDirection();\n      // Compensate scroll jump\n      if (scrollDirection === SCROLL_UP) {\n        const diff = calcTotalJump(jump);\n        if (diff) {\n          scrollTo(diff, true);\n        }\n      } else if (scrollDirection === SCROLL_MANUAL) {\n        const offset = store._getScrollOffset();\n        if (offset === 0) {\n          // Do nothing to stick to the start\n        } else {\n          const allDiff = calcTotalJump(jump);\n          if (\n            store._getScrollSize() -\n              (offset + store._getViewportSize() + allDiff) <=\n            0\n          ) {\n            // Keep end to stick to the end\n            if (allDiff) {\n              scrollTo(offset + allDiff);\n            }\n          } else {\n            // Keep start at mid\n            const diff = jump.reduce((acc, [j, index]) => {\n              if (index < startIndex) {\n                acc += j;\n              }\n              return acc;\n            }, 0);\n            if (diff) {\n              scrollTo(diff, true);\n            }\n          }\n        }\n      } else {\n        // NOP\n      }\n    },\n  };\n};\n","import { ReactNode } from \"react\";\nimport { exists } from \"../core/utils\";\n\nexport const refKey = \"current\";\n\nexport const isInvalidElement = <T extends ReactNode>(\n  e: T\n): e is Extract<T, null | undefined | boolean> =>\n  !exists(e) || typeof e === \"boolean\";\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import {\n  ACTION_ITEM_RESIZE,\n  ACTION_WINDOW_RESIZE,\n  ItemResize,\n  VirtualStore,\n} from \"./store\";\nimport { exists, max, once } from \"./utils\";\n\nexport const createResizer = (store: VirtualStore) => {\n  let resized = false;\n  let rootElement: HTMLElement | undefined;\n  const sizeKey = store._isHorizontal() ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          store._update(ACTION_WINDOW_RESIZE, contentRect[sizeKey]);\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n        resized = true;\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _isJustResized(): boolean {\n      const prev = resized;\n      resized = false;\n      return prev;\n    },\n  };\n};\n\nexport type Resizer = ReturnType<typeof createResizer>;\n\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let heightResized = false;\n  let widthResized = false;\n  let rootElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizedRows = new Set<number>();\n      const resizedCols = new Set<number>();\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          vStore._update(ACTION_WINDOW_RESIZE, contentRect[heightKey]);\n          hStore._update(ACTION_WINDOW_RESIZE, contentRect[widthKey]);\n        } else {\n          const cell = mountedIndexes.get(target);\n          if (cell) {\n            const [rowIndex, colIndex] = cell;\n            const key = getKey(rowIndex, colIndex);\n            const prevSize = sizeCache.get(key);\n            const size: CellSize = [\n              contentRect[heightKey],\n              contentRect[widthKey],\n            ];\n            let rowResized: boolean | undefined;\n            let colResized: boolean | undefined;\n            if (!prevSize) {\n              rowResized = colResized = true;\n            } else {\n              if (prevSize[0] !== size[0]) {\n                rowResized = true;\n              }\n              if (prevSize[1] !== size[1]) {\n                colResized = true;\n              }\n            }\n            if (rowResized) {\n              resizedRows.add(rowIndex);\n            }\n            if (colResized) {\n              resizedCols.add(colIndex);\n            }\n            if (rowResized || colResized) {\n              sizeCache.set(key, size);\n            }\n          }\n        }\n      }\n\n      if (resizedRows.size) {\n        const heightResizes: ItemResize[] = [];\n        resizedRows.forEach((rowIndex) => {\n          let maxHeight = 0;\n          maybeCachedColIndexes.forEach((colIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxHeight = max(maxHeight, size[0]);\n            }\n          });\n          if (maxHeight) {\n            heightResizes.push([rowIndex, maxHeight]);\n          }\n        });\n        vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n        heightResized = true;\n      }\n      if (resizedCols.size) {\n        const widthResizes: ItemResize[] = [];\n        resizedCols.forEach((colIndex) => {\n          let maxWidth = 0;\n          maybeCachedRowIndexes.forEach((rowIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxWidth = max(maxWidth, size[1]);\n            }\n          });\n          if (maxWidth) {\n            widthResizes.push([colIndex, maxWidth]);\n          }\n        });\n        hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n        widthResized = true;\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _isJustResized(horizontal?: boolean): boolean {\n      const prev = horizontal ? widthResized : heightResized;\n      if (horizontal) {\n        widthResized = false;\n      } else {\n        heightResized = false;\n      }\n      return prev;\n    },\n  };\n};\n\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n"],"names":["min","max","now","exists","v","range","length","cb","_","i","debounce","fn","ms","id","cancel","debouncedFn","throttle","time","args","n","once","called","cache","UNCACHED","getItemSize","index","size","setItemSize","computeOffset","isTotal","top","computeTotalSize","computeStartOffset","findIndex","distance","sum","h","findStartIndexWithOffset","offset","prevStartIndex","prevOffset","findEndIndex","hasUnmeasuredItemsInRange","startIndex","endIndex","resetCache","itemSize","SCROLL_STOP","SCROLL_DOWN","SCROLL_UP","SCROLL_MANUAL","ACTION_ITEM_RESIZE","ACTION_WINDOW_RESIZE","ACTION_SCROLL","ACTION_MANUAL_SCROLL","createVirtualStore","itemCount","isHorizontal","isRtl","initialItemCount","onScrollStateChange","onScrollOffsetChange","viewportSize","scrollOffset","jump","scrollDirection","_prevRange","_scrollToQueue","subscribers","prevEndIndex","start","end","resolve","reject","type","payload","updated","updatedJump","dir","prev","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useSyncExternalStore","subscibe","getSnapShot","_useSyncExternalStore","hasNegativeOffsetInRtl","scrollable","key","isNegative","createScroller","store","isJustResized","rootElement","scrollToKey","getActualScrollSize","scrollTo","diff","scrollManually","getCurrentOffset","getOffset","scrollSize","calcTotalJump","acc","j","root","syncViewportToScrollPosition","resized","onScrollStopped","onScroll","onWheel","e","count","allDiff","refKey","isInvalidElement","useStatic","init","ref","useRef","createResizer","sizeKey","mountedIndexes","getResizeObserver","entries","resizes","target","contentRect","ro","el","createGridResizer","vStore","hStore","heightResized","widthResized","heightKey","widthKey","maybeCachedRowIndexes","maybeCachedColIndexes","sizeCache","getKey","rowIndex","colIndex","resizedRows","resizedCols","cell","prevSize","rowResized","colResized","heightResizes","maxHeight","widthResizes","maxWidth","horizontal"],"mappings":"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"}