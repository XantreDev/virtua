{"version":3,"file":"VList-77c9ef0a.js","sources":["../../src/react/VList.tsx"],"sourcesContent":["import {\n  useRef,\n  useMemo,\n  ReactElement,\n  forwardRef,\n  useImperativeHandle,\n  ReactNode,\n  useEffect,\n} from \"react\";\nimport {\n  UPDATE_SCROLL_WITH_EVENT,\n  ACTION_ITEMS_LENGTH_CHANGE,\n  createVirtualStore,\n  UPDATE_SIZE,\n  UPDATE_JUMP,\n  UPDATE_SCROLL_DIRECTION,\n  UPDATE_SCROLL,\n  SCROLL_IDLE,\n} from \"../core/store\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { useSelector } from \"./useSelector\";\nimport { exists, values } from \"../core/utils\";\nimport { createScroller } from \"../core/scroller\";\nimport {\n  MayHaveKey,\n  clampEndIndex,\n  clampStartIndex,\n  emptyComponents,\n  flattenChildren,\n  refKey,\n} from \"./utils\";\nimport { useStatic } from \"./useStatic\";\nimport { useLatestRef } from \"./useLatestRef\";\nimport { createResizer } from \"../core/resizer\";\nimport { ViewportComponentAttributes } from \"..\";\nimport {\n  CustomViewportComponent,\n  CustomViewportComponentProps,\n  Viewport as DefaultViewport,\n} from \"./Viewport\";\nimport { CustomItemComponent, ListItem } from \"./ListItem\";\nimport { CacheSnapshot, ScrollToIndexAlign } from \"../core/types\";\nimport { Cache } from \"../core/cache\";\nimport { flushSync } from \"react-dom\";\n\nexport type ScrollMode = \"reverse\" | \"rtl\";\n\ntype CustomItemComponentOrElement =\n  | keyof JSX.IntrinsicElements\n  | CustomItemComponent;\n\n/**\n * Methods of {@link VList}.\n */\nexport interface VListHandle {\n  /**\n   * Get current {@link CacheSnapshot}.\n   */\n  readonly cache: CacheSnapshot;\n  /**\n   * Get current scrollTop or scrollLeft.\n   */\n  readonly scrollOffset: number;\n  /**\n   * Get current scrollHeight or scrollWidth.\n   */\n  readonly scrollSize: number;\n  /**\n   * Get current offsetHeight or offsetWidth.\n   */\n  readonly viewportSize: number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   * @param align alignment of item\n   */\n  scrollToIndex(index: number, align?: ScrollToIndexAlign): void;\n  /**\n   * Scroll to the given offset.\n   * @param offset offset from start\n   */\n  scrollTo(offset: number): void;\n  /**\n   * Scroll by the given offset.\n   * @param offset offset from current position\n   */\n  scrollBy(offset: number): void;\n}\n\n/**\n * Props of {@link VList}.\n */\nexport interface VListProps extends ViewportComponentAttributes {\n  /**\n   * Elements rendered by this component.\n   */\n  children: ReactNode;\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan?: number;\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  initialItemSize?: number;\n  /**\n   * If set, the specified amount of items will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.\n   */\n  initialItemCount?: number;\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are shifted/unshifted. It is useful for reverse infinite scrolling.\n   */\n  shift?: boolean;\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal?: boolean;\n  /**\n   * Scroll modes that should be set in certain situations.\n   *\n   * - `reverse`: This mode will adjust some styles to be suitable for bottom-to-top scrolling.\n   * - `rtl`: You have to set this mode if you use this component under `direction: rtl` style.\n   */\n  mode?: ScrollMode;\n  /**\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VListHandle.cache}.\n   */\n  cache?: CacheSnapshot;\n  /**\n   * Customized components for advanced usage.\n   */\n  components?: {\n    /**\n     * Component for scrollable element. This component will get {@link CustomViewportComponentProps} as props.\n     * @defaultValue {@link DefaultViewport}\n     */\n    Root?: CustomViewportComponent;\n    /**\n     * Component or element type for item element. This component will get {@link CustomItemComponentProps} as props.\n     * @defaultValue \"div\"\n     */\n    Item?: CustomItemComponentOrElement;\n  };\n  /**\n   * Callback invoked whenever scroll offset changes.\n   * @param offset Current scrollTop or scrollLeft.\n   */\n  onScroll?: (offset: number) => void;\n  /**\n   * Callback invoked when scrolling stops.\n   */\n  onScrollStop?: () => void;\n  /**\n   * Callback invoked when visible items range changes.\n   */\n  onRangeChange?: (\n    /**\n     * The start index of viewable items.\n     */\n    startIndex: number,\n    /**\n     * The end index of viewable items.\n     */\n    endIndex: number\n  ) => void;\n}\n\n/**\n * Virtualized list component. See {@link VListProps} and {@link VListHandle}.\n */\nexport const VList = forwardRef<VListHandle, VListProps>(\n  (\n    {\n      children,\n      overscan = 4,\n      initialItemSize,\n      initialItemCount,\n      shift,\n      horizontal: horizontalProp,\n      mode,\n      cache,\n      components: {\n        Root: Viewport = DefaultViewport,\n        Item: ItemElement = \"div\",\n      } = emptyComponents as {\n        Root?: undefined;\n        Item?: undefined;\n      },\n      onScroll: onScrollProp,\n      onScrollStop: onScrollStopProp,\n      onRangeChange: onRangeChangeProp,\n      ...viewportAttrs\n    },\n    ref\n  ): ReactElement => {\n    // Memoize element array\n    const elements = useMemo(() => flattenChildren(children), [children]);\n    const count = elements.length;\n\n    const onScroll = useLatestRef(onScrollProp);\n    const onScrollStop = useLatestRef(onScrollStopProp);\n\n    const [store, resizer, scroller, isHorizontal, isRtl] = useStatic(() => {\n      const _isHorizontal = !!horizontalProp;\n      const _isRtl = mode === \"rtl\";\n      const _store = createVirtualStore(\n        flushSync,\n        count,\n        initialItemSize,\n        initialItemCount,\n        cache as unknown as Cache | undefined,\n        mode === \"reverse\",\n        !initialItemSize\n      );\n      return [\n        _store,\n        createResizer(_store, _isHorizontal),\n        createScroller(_store, _isHorizontal, _isRtl),\n        _isHorizontal,\n        _isRtl,\n      ];\n    });\n\n    // The elements length and cached items length are different just after element is added/removed.\n    if (count !== store._getItemsLength()) {\n      store._update(ACTION_ITEMS_LENGTH_CHANGE, [count, shift]);\n    }\n\n    const [startIndex, endIndex] = useSelector(\n      store,\n      store._getRange,\n      UPDATE_SCROLL + UPDATE_SIZE\n    );\n    const scrollDirection = useSelector(\n      store,\n      store._getScrollDirection,\n      UPDATE_SCROLL_DIRECTION\n    );\n    const jumpCount = useSelector(store, store._getJumpCount, UPDATE_JUMP);\n    const scrollSize = useSelector(\n      store,\n      store._getCorrectedScrollSize,\n      UPDATE_SIZE,\n      true\n    );\n    const rootRef = useRef<HTMLDivElement>(null);\n    const scrolling = scrollDirection !== SCROLL_IDLE;\n\n    useIsomorphicLayoutEffect(() => {\n      const root = rootRef[refKey]!;\n      const unobserve = resizer._observeRoot(root);\n      const cleanup = scroller._initRoot(root);\n      const cleanupOnScroll = store._subscribe(UPDATE_SCROLL_WITH_EVENT, () => {\n        onScroll[refKey] && onScroll[refKey](store._getScrollOffset());\n      });\n      return () => {\n        unobserve();\n        cleanup();\n        cleanupOnScroll();\n      };\n    }, []);\n\n    useIsomorphicLayoutEffect(() => {\n      const jump = store._flushJump();\n      if (!jump) return;\n\n      scroller._fixScrollJump(jump);\n    }, [jumpCount]);\n\n    useEffect(() => {\n      if (!scrolling) {\n        onScrollStop[refKey] && onScrollStop[refKey]();\n      }\n    }, [scrolling]);\n\n    useEffect(() => {\n      if (!onRangeChangeProp) return;\n\n      onRangeChangeProp(startIndex, endIndex);\n    }, [startIndex, endIndex]);\n\n    useImperativeHandle(\n      ref,\n      () => {\n        return {\n          get cache() {\n            return store._getCache();\n          },\n          get scrollOffset() {\n            return store._getScrollOffset();\n          },\n          get scrollSize() {\n            return store._getCorrectedScrollSize();\n          },\n          get viewportSize() {\n            return store._getViewportSize();\n          },\n          scrollToIndex: scroller._scrollToIndex,\n          scrollTo: scroller._scrollTo,\n          scrollBy: scroller._scrollBy,\n        };\n      },\n      []\n    );\n\n    const overscanedStartIndex = clampStartIndex(\n      startIndex,\n      overscan,\n      scrollDirection\n    );\n    const overscanedEndIndex = clampEndIndex(\n      endIndex,\n      overscan,\n      scrollDirection,\n      count\n    );\n    const items = useMemo(() => {\n      const res: ReactElement[] = [];\n      for (let i = overscanedStartIndex; i <= overscanedEndIndex; i++) {\n        const e = elements[i]!;\n        const key = (e as MayHaveKey).key;\n        res.push(\n          <ListItem\n            key={exists(key) ? key : \"_\" + i}\n            _resizer={resizer}\n            _store={store}\n            _index={i}\n            _element={ItemElement as \"div\"}\n            _children={e}\n            _isHorizontal={isHorizontal}\n            _isRtl={isRtl}\n          />\n        );\n      }\n      return res;\n    }, [elements, overscanedStartIndex, overscanedEndIndex]);\n\n    return (\n      <Viewport\n        ref={rootRef}\n        width={isHorizontal ? scrollSize : undefined}\n        height={isHorizontal ? undefined : scrollSize}\n        scrolling={scrolling}\n        attrs={useMemo(\n          () => ({\n            ...viewportAttrs,\n            style: {\n              overflow: \"auto\",\n              display: isHorizontal ? \"inline-block\" : \"block\",\n              contain: \"strict\",\n              // transform: \"translate3d(0px, 0px, 0px)\",\n              // willChange: \"scroll-position\",\n              // backfaceVisibility: \"hidden\",\n              // https://github.com/bvaughn/react-window/issues/395\n              // willChange: \"transform\",\n              width: \"100%\",\n              height: \"100%\",\n              ...viewportAttrs.style,\n            },\n          }),\n          values(viewportAttrs)\n        )}\n      >\n        {items}\n      </Viewport>\n    );\n  }\n);\n"],"names":["VList","forwardRef","children","overscan","initialItemSize","initialItemCount","shift","horizontalProp","mode","cache","Viewport","DefaultViewport","ItemElement","emptyComponents","onScrollProp","onScrollStopProp","onRangeChangeProp","viewportAttrs","ref","elements","useMemo","flattenChildren","count","onScroll","useLatestRef","onScrollStop","store","resizer","scroller","isHorizontal","isRtl","useStatic","_isHorizontal","_isRtl","_store","createVirtualStore","flushSync","createResizer","createScroller","ACTION_ITEMS_LENGTH_CHANGE","startIndex","endIndex","useSelector","UPDATE_SCROLL","UPDATE_SIZE","scrollDirection","UPDATE_SCROLL_DIRECTION","jumpCount","UPDATE_JUMP","scrollSize","rootRef","useRef","scrolling","SCROLL_IDLE","useIsomorphicLayoutEffect","root","refKey","unobserve","cleanup","cleanupOnScroll","UPDATE_SCROLL_WITH_EVENT","jump","useEffect","useImperativeHandle","overscanedStartIndex","clampStartIndex","overscanedEndIndex","clampEndIndex","items","res","i","e","key","jsx","ListItem","exists","values"],"mappings":"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"}