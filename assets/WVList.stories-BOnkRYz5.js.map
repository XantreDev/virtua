{"version":3,"file":"WVList.stories-BOnkRYz5.js","sources":["../../src/react/WVList.tsx"],"sourcesContent":["import {\n  useRef,\n  useMemo,\n  ReactElement,\n  ReactNode,\n  useEffect,\n  forwardRef,\n  useImperativeHandle,\n} from \"react\";\nimport {\n  ACTION_ITEMS_LENGTH_CHANGE,\n  UPDATE_SCROLL_STATE,\n  UPDATE_SIZE_STATE,\n  createVirtualStore,\n  SCROLL_IDLE,\n} from \"../core/store\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { exists, values } from \"../core/utils\";\nimport { createWindowScroller } from \"../core/scroller\";\nimport {\n  MayHaveKey,\n  clampEndIndex,\n  clampStartIndex,\n  emptyComponents,\n  refKey,\n} from \"./utils\";\nimport { useStatic } from \"./useStatic\";\nimport { useLatestRef } from \"./useLatestRef\";\nimport { createWindowResizer } from \"../core/resizer\";\nimport { CacheSnapshot } from \"../core/types\";\nimport {\n  CustomViewportComponent,\n  CustomViewportComponentProps,\n  Viewport as DefaultViewport,\n  ViewportComponentAttributes,\n} from \"./Viewport\";\nimport { CustomItemComponent, ListItem } from \"./ListItem\";\nimport { Cache } from \"../core/cache\";\nimport { flushSync } from \"react-dom\";\nimport { useRerender } from \"./useRerender\";\nimport { useChildren } from \"./useChildren\";\n\ntype CustomItemComponentOrElement =\n  | keyof JSX.IntrinsicElements\n  | CustomItemComponent;\n\n/**\n * Methods of {@link WVList}.\n */\nexport interface WVListHandle {\n  /**\n   * Get current {@link CacheSnapshot}.\n   */\n  readonly cache: CacheSnapshot;\n}\n\n/**\n * Props of {@link WVList}.\n */\nexport interface WVListProps extends ViewportComponentAttributes {\n  /**\n   * Elements rendered by this component.\n   *\n   * You can also pass a function and set {@link WVListProps.count} to create elements lazily.\n   */\n  children: ReactNode | ((index: number) => ReactElement);\n  /**\n   * If you set a function to {@link WVListProps.children}, you have to set total number of items to this prop.\n   */\n  count?: number;\n  /**\n   * Number of items to render above/below the visible bounds of the list. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan?: number;\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  initialItemSize?: number;\n  /**\n   * If set, the specified amount of items will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.\n   */\n  initialItemCount?: number;\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are shifted/unshifted. It is useful for reverse infinite scrolling.\n   */\n  shift?: boolean;\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal?: boolean;\n  /**\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link WVListHandle.cache}.\n   */\n  cache?: CacheSnapshot;\n  /**\n   * Customized components for advanced usage.\n   */\n  components?: {\n    /**\n     * Component for scrollable element. This component will get {@link CustomViewportComponentProps} as props.\n     * @defaultValue {@link DefaultViewport}\n     */\n    Root?: CustomViewportComponent;\n    /**\n     * Component or element type for item element. This component will get {@link CustomItemComponentProps} as props.\n     * @defaultValue \"div\"\n     */\n    Item?: CustomItemComponentOrElement;\n  };\n  /**\n   * Callback invoked when scrolling stops.\n   */\n  onScrollStop?: () => void;\n  /**\n   * Callback invoked when visible items range changes.\n   */\n  onRangeChange?: (\n    /**\n     * The start index of viewable items.\n     */\n    startIndex: number,\n    /**\n     * The end index of viewable items.\n     */\n    endIndex: number\n  ) => void;\n}\n\n/**\n * Virtualized list component controlled by the window scrolling. See {@link WVListProps} and {@link WVListHandle}.\n */\nexport const WVList = forwardRef<WVListHandle, WVListProps>(\n  (\n    {\n      children,\n      count: renderCountProp,\n      overscan = 4,\n      initialItemSize,\n      initialItemCount,\n      shift,\n      horizontal: horizontalProp,\n      cache,\n      components: {\n        Root: Viewport = DefaultViewport,\n        Item: ItemElement = \"div\",\n      } = emptyComponents as {\n        Root?: undefined;\n        Item?: undefined;\n      },\n      onScrollStop: onScrollStopProp,\n      onRangeChange: onRangeChangeProp,\n      ...viewportAttrs\n    },\n    ref\n  ): ReactElement => {\n    const [getElement, count] = useChildren(children, renderCountProp);\n\n    const onScrollStop = useLatestRef(onScrollStopProp);\n\n    const [store, resizer, scroller, isHorizontal] = useStatic(() => {\n      const _isHorizontal = !!horizontalProp;\n      const _store = createVirtualStore(\n        count,\n        initialItemSize,\n        initialItemCount,\n        cache as unknown as Cache | undefined,\n        false,\n        !initialItemSize\n      );\n\n      return [\n        _store,\n        createWindowResizer(_store, _isHorizontal),\n        createWindowScroller(_store, _isHorizontal),\n        _isHorizontal,\n      ];\n    });\n    // The elements length and cached items length are different just after element is added/removed.\n    if (count !== store._getItemsLength()) {\n      store._update(ACTION_ITEMS_LENGTH_CHANGE, [count, shift]);\n    }\n\n    const rerender = useRerender();\n\n    const [startIndex, endIndex] = store._getRange();\n    const scrollDirection = store._getScrollDirection();\n    const jumpCount = store._getJumpCount();\n    const scrollSize = store._getScrollSize();\n\n    const rootRef = useRef<HTMLDivElement>(null);\n    const scrolling = scrollDirection !== SCROLL_IDLE;\n\n    useIsomorphicLayoutEffect(() => {\n      const root = rootRef[refKey]!;\n      // store must be subscribed first because others may dispatch update on init depending on implementation\n      const unsubscribeStore = store._subscribe(\n        UPDATE_SCROLL_STATE + UPDATE_SIZE_STATE,\n        (sync) => {\n          if (sync) {\n            flushSync(rerender);\n          } else {\n            rerender();\n          }\n        }\n      );\n      const cleanupResizer = resizer._observeRoot(root);\n      const cleanupScroller = scroller._observe(root);\n      return () => {\n        unsubscribeStore();\n        cleanupResizer();\n        cleanupScroller();\n      };\n    }, []);\n\n    useIsomorphicLayoutEffect(() => {\n      const jump = store._flushJump();\n      if (!jump) return;\n\n      scroller._fixScrollJump(jump);\n    }, [jumpCount]);\n\n    useEffect(() => {\n      if (!scrolling) {\n        onScrollStop[refKey] && onScrollStop[refKey]();\n      }\n    }, [scrolling]);\n\n    useEffect(() => {\n      if (!onRangeChangeProp) return;\n\n      onRangeChangeProp(startIndex, endIndex);\n    }, [startIndex, endIndex]);\n\n    useImperativeHandle(\n      ref,\n      () => {\n        return {\n          get cache() {\n            return store._getCache();\n          },\n        };\n      },\n      []\n    );\n\n    const overscanedStartIndex = clampStartIndex(\n      startIndex,\n      overscan,\n      scrollDirection\n    );\n    const overscanedEndIndex = clampEndIndex(\n      endIndex,\n      overscan,\n      scrollDirection,\n      count\n    );\n\n    const items: ReactElement[] = [];\n    for (let i = overscanedStartIndex; i <= overscanedEndIndex; i++) {\n      const e = getElement(i);\n      const key = (e as MayHaveKey).key;\n      items.push(\n        <ListItem\n          key={exists(key) ? key : \"_\" + i}\n          _resizer={resizer}\n          _index={i}\n          _offset={store._getItemOffset(i)}\n          _hide={store._isUnmeasuredItem(i)}\n          _element={ItemElement as \"div\"}\n          _children={e}\n          _isHorizontal={isHorizontal}\n        />\n      );\n    }\n\n    return (\n      <Viewport\n        ref={rootRef}\n        width={isHorizontal ? scrollSize : undefined}\n        height={isHorizontal ? undefined : scrollSize}\n        scrolling={scrolling}\n        attrs={useMemo(\n          () => ({\n            ...viewportAttrs,\n            style: {\n              display: isHorizontal ? \"inline-block\" : \"block\",\n              width: isHorizontal ? \"auto\" : \"100%\",\n              height: isHorizontal ? \"100%\" : \"auto\",\n              ...viewportAttrs.style,\n            },\n          }),\n          values(viewportAttrs)\n        )}\n      >\n        {items}\n      </Viewport>\n    );\n  }\n);\n"],"names":["WVList","forwardRef","children","renderCountProp","overscan","initialItemSize","initialItemCount","shift","horizontalProp","cache","Viewport","DefaultViewport","ItemElement","emptyComponents","onScrollStopProp","onRangeChangeProp","viewportAttrs","ref","getElement","count","useChildren","onScrollStop","useLatestRef","store","resizer","scroller","isHorizontal","useStatic","_isHorizontal","_store","createVirtualStore","createWindowResizer","createWindowScroller","ACTION_ITEMS_LENGTH_CHANGE","rerender","useRerender","startIndex","endIndex","scrollDirection","jumpCount","scrollSize","rootRef","useRef","scrolling","SCROLL_IDLE","useIsomorphicLayoutEffect","root","refKey","unsubscribeStore","UPDATE_SCROLL_STATE","UPDATE_SIZE_STATE","sync","flushSync","cleanupResizer","cleanupScroller","jump","useEffect","useImperativeHandle","overscanedStartIndex","clampStartIndex","overscanedEndIndex","clampEndIndex","items","i","e","key","jsx","ListItem","exists","useMemo","values"],"mappings":"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"}