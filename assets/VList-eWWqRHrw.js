import{a as n}from"./jsx-runtime-sgeEVxPu.js";import{r as o}from"./index-yp3VsGQP.js";import{V as k}from"./Virtualizer-CBwl8dh-.js";const r=o.forwardRef(({children:i,count:s,overscan:u,itemSize:d,shift:m,horizontal:e,reverse:c,cache:f,ssrCount:p,item:h,onScroll:y,onScrollEnd:b,onRangeChange:v,style:V,...g},w)=>{const l=o.useRef(null),a=c&&!e;let t=n(k,{ref:w,scrollRef:a?l:void 0,count:s,overscan:u,itemSize:d,shift:m,horizontal:e,cache:f,ssrCount:p,item:h,onScroll:y,onScrollEnd:b,onRangeChange:v,children:i});return a&&(t=n("div",{style:{visibility:"hidden",display:"flex",flexDirection:"column",justifyContent:"flex-end",minHeight:"100%"},children:t})),n("div",{ref:l,...g,style:{display:e?"inline-block":"block",[e?"overflowX":"overflowY"]:"auto",contain:"strict",width:"100%",height:"100%",...V},children:t})});try{r.displayName="VList",r.__docgenInfo={description:"Virtualized list component. See {@link VListProps} and {@link VListHandle}.",displayName:"VList",props:{reverse:{defaultValue:null,description:"If true, items are aligned to the end of the list when total size of items are smaller than viewport size. It's useful for chat like app.",name:"reverse",required:!1,type:{name:"boolean"}},count:{defaultValue:null,description:"If you set a function to {@link VirtualizerProps.children}, you have to set total number of items to this prop.",name:"count",required:!1,type:{name:"number"}},children:{defaultValue:null,description:`Elements rendered by this component.

You can also pass a function and set {@link VirtualizerProps.count} to create elements lazily.`,name:"children",required:!0,type:{name:"ReactNode | ((index: number) => ReactElement<any, string | JSXElementConstructor<any>>)"}},overscan:{defaultValue:null,description:`Number of items to render above/below the visible bounds of the list. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 4`,name:"overscan",required:!1,type:{name:"number"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"itemSize",required:!1,type:{name:"number"}},shift:{defaultValue:null,description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",name:"shift",required:!1,type:{name:"boolean"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean"}},cache:{defaultValue:null,description:"You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.",name:"cache",required:!1,type:{name:"CacheSnapshot"}},ssrCount:{defaultValue:null,description:"A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated.",name:"ssrCount",required:!1,type:{name:"number"}},item:{defaultValue:null,description:`Component or element type for item element. This component will get {@link CustomItemComponentProps } as props.
@defaultValue "div"`,name:"item",required:!1,type:{name:"keyof IntrinsicElements | CustomItemComponent"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop or scrollLeft.`,name:"onScroll",required:!1,type:{name:"((offset: number) => void)"}},onScrollEnd:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollEnd",required:!1,type:{name:"(() => void)"}},onRangeChange:{defaultValue:null,description:"Callback invoked when visible items range changes.",name:"onRangeChange",required:!1,type:{name:"((startIndex: number, endIndex: number) => void)"}}}}}catch{}export{r as V};
