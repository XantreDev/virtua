{"version":3,"file":"Window-f3816797.js","sources":["../../src/core/utils.ts","../../src/core/cache.ts","../../src/core/store.ts","../../src/react/useIsomorphicLayoutEffect.ts","../../src/react/utils.ts","../../src/react/useRefWithUpdate.ts","../../src/react/useSelector.ts","../../src/core/dom.ts","../../src/core/scroller.ts","../../src/react/useStatic.ts","../../src/core/resizer.ts","../../src/react/Window.tsx"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const abs = Math.abs;\nexport const now = Date.now;\nexport const values = Object.values;\nexport const timeout = setTimeout;\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const range = <T>(length: number, cb: (i: number) => T): T[] =>\n  Array.from({ length }, (_, i) => cb(i));\n\nexport const median = (arr: number[]): number => {\n  const s = [...arr].sort((a, b) => a - b);\n  const mid = (arr.length / 2) | 0;\n  return s.length % 2 === 0 ? (s[mid - 1]! + s[mid]!) / 2 : s[mid]!;\n};\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: NodeJS.Timeout | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = timeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { exists, max, median, min, range } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _measuredOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n): boolean => {\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._measuredOffsetIndex = min(index, cache._measuredOffsetIndex);\n  return isInitialMeasurement;\n};\n\nconst computeOffset = (\n  cache: Writeable<Cache>,\n  index: number,\n  isTotal?: boolean\n): number => {\n  if (!cache._length) return 0;\n  if (cache._measuredOffsetIndex >= index) {\n    if (isTotal) {\n      return cache._offsets[index]! + getItemSize(cache, index);\n    } else {\n      return cache._offsets[index]!;\n    }\n  }\n\n  let i = cache._measuredOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i <= index) {\n    cache._offsets[i] = top;\n    if (i === index && !isTotal) {\n      break;\n    }\n    top += getItemSize(cache, i);\n    i++;\n  }\n  // mark as measured\n  cache._measuredOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  return computeOffset(cache, cache._length - 1, true);\n};\n\nexport const computeStartOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  return computeOffset(cache, index);\n};\n\nconst findIndex = (cache: Cache, i: number, distance: number): number => {\n  let sum = 0;\n  if (distance >= 0) {\n    // search forward\n    while (i < cache._length - 1) {\n      const h = getItemSize(cache, i++);\n      if ((sum += h) >= distance) {\n        if (sum - h / 2 >= distance) {\n          i--;\n        }\n        break;\n      }\n    }\n  } else {\n    // search backward\n    while (i > 0) {\n      const h = getItemSize(cache, --i);\n      if ((sum -= h) <= distance) {\n        if (sum + h / 2 < distance) {\n          i++;\n        }\n        break;\n      }\n    }\n  }\n\n  return min(max(i, 0), cache._length - 1);\n};\n\nexport const findStartIndexWithOffset = (\n  cache: Cache,\n  offset: number,\n  prevStartIndex: number,\n  prevOffset: number\n): number => {\n  return findIndex(cache, prevStartIndex, offset - prevOffset);\n};\n\nexport { findIndex as findEndIndex };\n\nexport const hasUnmeasuredItemsInRange = (\n  cache: Cache,\n  startIndex: number,\n  endIndex: number\n): boolean => {\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (cache._sizes[i] === UNCACHED) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const estimateDefaultItemSize = (cache: Writeable<Cache>) => {\n  const measuredSizes = cache._sizes.filter((s) => s !== UNCACHED);\n  // This function will be called after measurement so measured size array must be longer than 0\n  const startItemSize = measuredSizes[0]!;\n\n  cache._defaultItemSize = measuredSizes.every((s) => s === startItemSize)\n    ? // Maybe a fixed size array\n      startItemSize\n    : // Maybe a variable size array\n      median(measuredSizes);\n};\n\nexport const resetCache = (\n  length: number,\n  itemSize: number,\n  cache?: Cache\n): Cache => {\n  return {\n    _defaultItemSize: cache ? cache._defaultItemSize : itemSize,\n    _length: length,\n    _measuredOffsetIndex: cache\n      ? min(cache._measuredOffsetIndex, length - 1)\n      : 0,\n    _sizes: range(length, (i) => {\n      const size = cache && cache._sizes[i];\n      if (exists(size)) {\n        return size;\n      }\n      return UNCACHED;\n    }),\n    _offsets: range(length, (i) => {\n      if (i === 0) {\n        // first offset must be 0\n        return 0;\n      }\n      const offset = cache && cache._offsets[i];\n      if (exists(offset)) {\n        return offset;\n      }\n      return UNCACHED;\n    }),\n  };\n};\n","import {\n  findStartIndexWithOffset,\n  resetCache,\n  getItemSize,\n  computeTotalSize,\n  findEndIndex,\n  computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  hasUnmeasuredItemsInRange,\n  estimateDefaultItemSize,\n} from \"./cache\";\nimport type { Writeable } from \"./types\";\nimport { abs, exists, max, min } from \"./utils\";\n\ntype ItemJump = Readonly<[sizeDiff: number, index: number]>;\nexport type ScrollJump = Readonly<number>;\nexport type ItemResize = Readonly<[index: number, size: number]>;\ntype ItemsRange = Readonly<[startIndex: number, endIndex: number]>;\n\nconst sumJumps = (jump: readonly ItemJump[]): number =>\n  jump.reduce((acc, [j]) => acc + j, 0);\nconst calculateJumps = (cache: Cache, items: ItemResize[]): ItemJump[] => {\n  return items.map(([index, size]) => {\n    return [size - getItemSize(cache, index), index];\n  });\n};\n\nconst SUBPIXEL_THRESHOLD = 1.5; // 0.5 * 3\n\nexport const SCROLL_IDLE = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\nexport const SCROLL_MANUAL = 3;\ntype ScrollDirection =\n  | typeof SCROLL_IDLE\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP\n  | typeof SCROLL_MANUAL;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_WINDOW_RESIZE = 2;\nexport const ACTION_SCROLL = 3;\nexport const ACTION_MANUAL_SCROLL = 4;\nexport const ACTION_SCROLL_END = 5;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_WINDOW_RESIZE, size: number]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, offset: number]\n  | [type: typeof ACTION_SCROLL_END, isManual: boolean];\n\ntype Subscriber = (sync?: boolean) => void;\n\nexport const UPDATE_SCROLL = 0b001;\nexport const UPDATE_SIZE = 0b010;\nexport const UPDATE_JUMP = 0b100;\n\nexport type VirtualStore = {\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInRange(startIndex: number): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getItemLength(): number;\n  _getScrollOffset(): number;\n  _getScrollOffsetMax(): number;\n  _getViewportSize(): number;\n  _getScrollSize(): number;\n  _getCorrectedScrollSize(): number;\n  _getJumpCount(): number;\n  _flushJump(): ScrollJump | undefined;\n  _getItemIndexForScrollTo(offset: number): number;\n  _subscribe(target: number, cb: Subscriber): () => void;\n  _update(...action: Actions): void;\n  _getScrollDirection(): ScrollDirection;\n  _updateCacheLength(length: number): void;\n};\n\nexport const createVirtualStore = (\n  elementsCount: number,\n  itemSize: number | undefined,\n  initialItemCount: number = 0,\n  isReverse: boolean,\n  onScrollStateChange: (scrolling: boolean) => void,\n  onScrollOffsetChange?: (offset: number) => void\n): VirtualStore => {\n  const shouldAutoEstimateItemSize = !itemSize;\n  const initialItemSize = itemSize || 40;\n  let viewportSize = initialItemSize * max(initialItemCount - 1, 0);\n  let scrollOffset = 0;\n  let jumpCount = 0;\n  let jump: ScrollJump | undefined;\n  let cache = resetCache(elementsCount, initialItemSize);\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\n  let _resized = false;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n\n  const subscribers = new Set<[number, Subscriber]>();\n  const getScrollSize = (): number =>\n    computeTotalSize(cache as Writeable<Cache>);\n  const getScrollOffsetMax = () => getScrollSize() - viewportSize;\n\n  const flushIsJustResized = (): boolean => {\n    const prev = _resized;\n    _resized = false;\n    return prev;\n  };\n  const updateScrollDirection = (dir: ScrollDirection): boolean | undefined => {\n    const prev = _scrollDirection;\n    _scrollDirection = dir;\n    if (_scrollDirection === SCROLL_IDLE) {\n      return false;\n    } else if (\n      prev === SCROLL_IDLE &&\n      (_scrollDirection === SCROLL_DOWN || _scrollDirection === SCROLL_UP)\n    ) {\n      return true;\n    }\n    return;\n  };\n\n  return {\n    _getRange() {\n      const [prevStartIndex, prevEndIndex] = _prevRange;\n      const prevOffset = computeStartOffset(\n        cache as Writeable<Cache>,\n        prevStartIndex\n      );\n      const start = findStartIndexWithOffset(\n        cache,\n        scrollOffset,\n        prevStartIndex,\n        prevOffset\n      );\n      const end = findEndIndex(cache, start, viewportSize);\n      if (prevStartIndex === start && prevEndIndex === end) {\n        return _prevRange;\n      }\n      return (_prevRange = [start, end]);\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInRange(startIndex) {\n      return hasUnmeasuredItemsInRange(\n        cache,\n        max(0, startIndex - 2),\n        min(cache._length - 1, startIndex + 2)\n      );\n    },\n    _getItemOffset(index) {\n      const offset = computeStartOffset(cache as Writeable<Cache>, index);\n      if (isReverse) {\n        return offset + max(0, viewportSize - getScrollSize());\n      }\n      return offset;\n    },\n    _getItemSize(index) {\n      return getItemSize(cache, index);\n    },\n    _getItemLength() {\n      return cache._length;\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getScrollOffsetMax: getScrollOffsetMax,\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getScrollSize: getScrollSize,\n    _getCorrectedScrollSize() {\n      return max(getScrollSize(), viewportSize);\n    },\n    _getJumpCount() {\n      return jumpCount;\n    },\n    _flushJump() {\n      const prevJump = jump;\n      jump = undefined;\n      return prevJump;\n    },\n    _getItemIndexForScrollTo(offset) {\n      return findStartIndexWithOffset(cache, offset, 0, 0);\n    },\n    _subscribe(target, cb) {\n      const sub: [number, Subscriber] = [target, cb];\n      subscribers.add(sub);\n      return () => {\n        subscribers.delete(sub);\n      };\n    },\n    _update(type, payload): void {\n      let shouldSync: boolean | undefined;\n      let updatedScrollState: boolean | undefined;\n      let mutated = 0;\n\n      switch (type) {\n        case ACTION_ITEM_RESIZE: {\n          const updated = payload.filter(\n            ([index, size]) => cache._sizes[index] !== size\n          );\n          // Skip if all items are cached and not updated\n          if (!updated.length) {\n            break;\n          }\n\n          let diff = 0;\n          // Calculate jump\n          if (_scrollDirection === SCROLL_UP) {\n            diff = sumJumps(calculateJumps(cache, updated));\n          } else if (_scrollDirection === SCROLL_MANUAL) {\n            const allJumps = calculateJumps(cache, updated);\n            const [startIndex] = _prevRange;\n\n            if (scrollOffset === 0) {\n              // Do nothing to stick to the start\n            }\n            // Check including subpixels because window.devicePixelRatio can have decimal value\n            else if (scrollOffset > getScrollOffsetMax() - SUBPIXEL_THRESHOLD) {\n              // Keep end to stick to the end\n              diff = sumJumps(allJumps);\n            } else {\n              // Keep start at mid\n              diff = sumJumps(\n                allJumps.filter(([, index]) => index < startIndex)\n              );\n            }\n          } else {\n            // Do nothing\n          }\n\n          if (diff) {\n            jump = diff;\n            jumpCount++;\n            mutated += UPDATE_JUMP;\n          }\n\n          // Update item sizes\n          let isNewItemMeasured = false;\n          updated.forEach(([index, size]) => {\n            if (setItemSize(cache as Writeable<Cache>, index, size)) {\n              isNewItemMeasured = true;\n            }\n          });\n\n          // Estimate initial item size from measured sizes\n          if (\n            shouldAutoEstimateItemSize &&\n            isNewItemMeasured &&\n            // TODO support reverse scroll also\n            !scrollOffset\n          ) {\n            estimateDefaultItemSize(cache as Writeable<Cache>);\n          }\n          mutated += UPDATE_SIZE;\n          _resized = shouldSync = true;\n          break;\n        }\n        case ACTION_WINDOW_RESIZE: {\n          if (viewportSize !== payload) {\n            mutated = UPDATE_SIZE;\n          }\n          viewportSize = payload;\n          break;\n        }\n        case ACTION_SCROLL:\n        case ACTION_MANUAL_SCROLL: {\n          // Skip if offset is not changed\n          if (scrollOffset === payload) {\n            break;\n          }\n\n          if (type === ACTION_SCROLL) {\n            // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n            // Scroll events are dispatched enough so it's ok to skip some of them.\n            const isJustResized = flushIsJustResized();\n            if (\n              (_scrollDirection === SCROLL_IDLE || !isJustResized) &&\n              // Ignore until manual scrolling\n              _scrollDirection !== SCROLL_MANUAL\n            ) {\n              updatedScrollState = updateScrollDirection(\n                scrollOffset > payload ? SCROLL_UP : SCROLL_DOWN\n              );\n            }\n\n            // Ignore manual scroll because it may be called in useEffect/useLayoutEffect and cause the warn below.\n            // Warning: flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\n            //\n            // Update synchronously if scrolled a lot\n            shouldSync = abs(scrollOffset - payload) > viewportSize;\n          }\n\n          // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\n          scrollOffset = max(0, min(getScrollOffsetMax(), payload));\n          mutated = UPDATE_SCROLL;\n          break;\n        }\n        case ACTION_SCROLL_END: {\n          updatedScrollState = updateScrollDirection(\n            payload ? SCROLL_MANUAL : SCROLL_IDLE\n          );\n          break;\n        }\n      }\n\n      if (mutated) {\n        subscribers.forEach(([target, cb]) => {\n          // Early return to skip React's computation\n          if (!(mutated & target)) {\n            return;\n          }\n          cb(shouldSync);\n        });\n\n        if (type === ACTION_SCROLL) {\n          onScrollOffsetChange && onScrollOffsetChange(scrollOffset);\n        }\n      }\n      if (exists(updatedScrollState)) {\n        onScrollStateChange(updatedScrollState);\n      }\n    },\n    _getScrollDirection() {\n      return _scrollDirection;\n    },\n    _updateCacheLength(length) {\n      // It's ok to be updated in render because states should be calculated consistently regardless cache length\n      if (cache._length === length) return;\n      cache = resetCache(length, initialItemSize, cache);\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { Children, ReactElement, ReactFragment, ReactNode } from \"react\";\nimport { exists } from \"../core/utils\";\n\nexport const refKey = \"current\";\n\nexport const flattenChildren = (children: ReactNode) => {\n  const arr: (ReactElement | ReactFragment | string | number)[] = [];\n  Children.forEach(children, (e) => {\n    if (!exists(e) || typeof e === \"boolean\") {\n      return;\n    }\n    arr.push(e);\n  });\n  return arr;\n};\n","import { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { refKey } from \"./utils\";\n\nexport const useRefWithUpdate = <T>(value: T) => {\n  const ref = useRef<T>(value);\n\n  useIsomorphicLayoutEffect(() => {\n    ref[refKey] = value;\n  }, [value]);\n\n  return ref;\n};\n","import { useLayoutEffect, useState } from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { useRefWithUpdate } from \"./useRefWithUpdate\";\nimport { refKey } from \"./utils\";\nimport {\n  UPDATE_JUMP,\n  UPDATE_SCROLL,\n  UPDATE_SIZE,\n  VirtualStore,\n} from \"../core/store\";\n\nexport const useSelector = <T>(\n  store: VirtualStore,\n  getSnapShot: () => T,\n  shouldGetLatest?: boolean\n): T => {\n  const [state, setState] = useState(getSnapShot);\n  const getter = useRefWithUpdate(getSnapShot);\n\n  useLayoutEffect(() => {\n    let target: number;\n    if (getSnapShot === store._getRange) {\n      target = UPDATE_SCROLL + UPDATE_SIZE;\n    } else if (getSnapShot === store._getCorrectedScrollSize) {\n      target = UPDATE_SIZE;\n    } else if (getSnapShot === store._getJumpCount) {\n      target = UPDATE_JUMP;\n    } else {\n      // Others will be item subscribers\n      target = UPDATE_SIZE;\n    }\n\n    const update = () => {\n      setState(() => getter[refKey]());\n    };\n    return store._subscribe(target, (sync) => {\n      // TODO batch flushSync to remove shouldGetLatest argument if possible\n      // https://github.com/facebook/react/issues/25191\n      if (sync) {\n        flushSync(update);\n      } else {\n        update();\n      }\n    });\n  }, []);\n\n  // especially for sort of items\n  if (shouldGetLatest) {\n    const snap = getSnapShot();\n    if (state !== snap) {\n      setState(snap);\n    }\n  }\n  return state;\n};\n","import { once } from \"./utils\";\n\n// The scroll position may be negative value in rtl direction.\n//\n// left  right result\n// -100  0     true    spec compliant\n// 0     100   false   probably Chrome earlier than v85\n// https://github.com/othree/jquery.rtl-scroll-type\nexport const hasNegativeOffsetInRtl = /*#__PURE__*/ once(\n  (scrollable: HTMLElement) => {\n    const key = \"scrollLeft\";\n    const prev = scrollable[key];\n    scrollable[key] = 1;\n    // scrollLeft can be positive under some specific situations even if negative mode, so we use `<` for now.\n    const isNegative = scrollable[key] < 1;\n    scrollable[key] = prev;\n    return isNegative;\n  }\n);\n","import { hasNegativeOffsetInRtl } from \"./dom\";\nimport {\n  ACTION_SCROLL,\n  ACTION_MANUAL_SCROLL,\n  ScrollJump,\n  VirtualStore,\n  SCROLL_IDLE,\n  ACTION_SCROLL_END,\n  UPDATE_SIZE,\n} from \"./store\";\nimport { debounce, throttle, max, min, timeout } from \"./utils\";\n\n// Infer scroll state also from wheel events\n// Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\nconst createOnWheel = (\n  store: VirtualStore,\n  isHorizontal: boolean,\n  onScrollStopped: () => void\n) => {\n  return throttle((e: WheelEvent) => {\n    if (store._getScrollDirection() === SCROLL_IDLE) {\n      // Scroll start should be detected with scroll event\n      return;\n    }\n    if (e.ctrlKey) {\n      // Probably a pinch-to-zoom gesture\n      return;\n    }\n    // Get delta before checking deltaMode for firefox behavior\n    // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n    if (isHorizontal ? e.deltaX : e.deltaY) {\n      const offset = store._getScrollOffset();\n      if (offset > 0 && offset < store._getScrollOffsetMax()) {\n        onScrollStopped();\n      }\n    }\n  }, 50);\n};\n\nexport type Scroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _getActualScrollSize: () => number;\n  _scrollTo: (offset: number) => void;\n  _scrollToIndex: (index: number) => void;\n  _fixScrollJump: (jump: ScrollJump) => void;\n};\n\nexport const createScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean,\n  isRtl: boolean\n): Scroller => {\n  let rootElement: HTMLElement | undefined;\n  let scrollToQueue: [() => void, () => void] | undefined;\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n\n  const getActualScrollSize = (): number => {\n    if (!rootElement) return 0;\n    // Use element's scrollHeight/scrollWidth instead of stored scrollSize.\n    // This is because stored size may differ from the actual size, for example when a new item is added and not yet measured.\n    return isHorizontal ? rootElement.scrollWidth : rootElement.scrollHeight;\n  };\n  const normalizeOffset = (offset: number, diff?: boolean): number => {\n    if (isHorizontal && isRtl) {\n      if (hasNegativeOffsetInRtl(rootElement!)) {\n        return -offset;\n      } else {\n        return diff ? -offset : store._getScrollOffsetMax() - offset;\n      }\n    }\n    return offset;\n  };\n\n  const scrollManually = async (\n    index: number,\n    getCurrentOffset: () => number\n  ) => {\n    if (!rootElement) return;\n\n    const getOffset = (): number => {\n      // Adjust if the offset is over the end, to get correct startIndex.\n      return min(\n        getCurrentOffset(),\n        getActualScrollSize() - store._getViewportSize()\n      );\n    };\n\n    while (true) {\n      // Sync viewport to scroll destination\n      // In order to scroll to the correct position, mount the items and measure their sizes before scrolling.\n      store._update(ACTION_MANUAL_SCROLL, getOffset());\n\n      if (!store._hasUnmeasuredItemsInRange(index)) {\n        break;\n      }\n\n      if (scrollToQueue) {\n        // Cancel waiting scrollTo\n        scrollToQueue[1]();\n      }\n\n      // Wait for the scroll destination items to be measured.\n      const unsubscribe = store._subscribe(UPDATE_SIZE, () => {\n        scrollToQueue && scrollToQueue[0]();\n      });\n      try {\n        // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n        // For example, ResizeObserver may not fire when window is not visible.\n        await new Promise<void>((resolve, reject) => {\n          let resolved = false;\n\n          const resolveQueue = () => {\n            if (resolved) return;\n            resolved = true;\n            resolve();\n            scrollToQueue = undefined;\n          };\n          scrollToQueue = [resolveQueue, reject];\n\n          // In some specific situation with VGrid, the promise never resolved so we cancel it if timed out.\n          timeout(resolveQueue, 250);\n        });\n      } catch (e) {\n        // canceled\n        return;\n      } finally {\n        unsubscribe();\n      }\n    }\n\n    // Scroll with the updated value\n    rootElement[scrollToKey] = normalizeOffset(getOffset());\n    store._update(ACTION_SCROLL_END, true);\n  };\n\n  return {\n    _initRoot(root) {\n      rootElement = root;\n\n      const syncViewportToScrollPosition = () => {\n        store._update(ACTION_SCROLL, normalizeOffset(root[scrollToKey]));\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._update(ACTION_SCROLL_END, false);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      const onWheel = createOnWheel(store, isHorizontal, onScrollStopped);\n\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _getActualScrollSize: getActualScrollSize,\n    _scrollTo(offset) {\n      offset = max(offset, 0);\n\n      scrollManually(store._getItemIndexForScrollTo(offset), () => offset);\n    },\n    _scrollToIndex(index) {\n      index = max(min(index, store._getItemLength() - 1), 0);\n\n      scrollManually(index, () => store._getItemOffset(index));\n    },\n    _fixScrollJump: (jump) => {\n      if (!rootElement) return;\n      rootElement[scrollToKey] += normalizeOffset(jump, true);\n    },\n  };\n};\n\nexport type WindowScroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _fixScrollJump: (jump: ScrollJump) => void;\n};\n\nexport const createWindowScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowScroller => {\n  const scrollToKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n  const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n\n  return {\n    _initRoot(rootElement) {\n      let visible = false;\n\n      const getOffsetToWindow = (node: HTMLElement, offset: number): number => {\n        const nodeOffset = offset + node[offsetKey];\n\n        const parent = node.offsetParent;\n        if (node === document.body || !parent) {\n          return nodeOffset;\n        }\n\n        return getOffsetToWindow(parent as HTMLElement, nodeOffset);\n      };\n\n      const syncViewportToScrollPosition = () => {\n        if (!visible) return;\n        store._update(\n          ACTION_SCROLL,\n          window[scrollToKey] - getOffsetToWindow(rootElement, 0)\n        );\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._update(ACTION_SCROLL_END, false);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      const onWheel = createOnWheel(store, isHorizontal, onScrollStopped);\n\n      const io = new IntersectionObserver(([entry]) => {\n        visible = entry!.isIntersecting;\n      });\n      io.observe(rootElement);\n\n      window.addEventListener(\"scroll\", onScroll);\n      window.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        io.disconnect();\n        window.removeEventListener(\"scroll\", onScroll);\n        window.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _fixScrollJump: (jump) => {\n      // TODO support case two window scrollers exist in the same view\n      window.scrollBy(isHorizontal ? jump : 0, isHorizontal ? 0 : jump);\n    },\n  };\n};\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import {\n  ACTION_ITEM_RESIZE,\n  ACTION_WINDOW_RESIZE,\n  ItemResize,\n  VirtualStore,\n} from \"./store\";\nimport { exists, max, once } from \"./utils\";\n\nexport interface ListResizer {\n  _observeRoot(root: HTMLElement): () => void;\n  _observeItem(el: HTMLElement, i: number): () => void;\n}\n\nexport const createResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  let rootElement: HTMLElement | undefined;\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          store._update(ACTION_WINDOW_RESIZE, contentRect[sizeKey]);\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport const createWindowResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        const index = mountedIndexes.get(target);\n        if (exists(index)) {\n          resizes.push([index, contentRect[sizeKey]]);\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot() {\n      const cb = () => {\n        store._update(ACTION_WINDOW_RESIZE, window[windowSizeKey]);\n      };\n      window.addEventListener(\"resize\", cb);\n      cb();\n      return () => {\n        window.removeEventListener(\"resize\", cb);\n        getResizeObserver().disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let rootElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizedRows = new Set<number>();\n      const resizedCols = new Set<number>();\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          vStore._update(ACTION_WINDOW_RESIZE, contentRect[heightKey]);\n          hStore._update(ACTION_WINDOW_RESIZE, contentRect[widthKey]);\n        } else {\n          const cell = mountedIndexes.get(target);\n          if (cell) {\n            const [rowIndex, colIndex] = cell;\n            const key = getKey(rowIndex, colIndex);\n            const prevSize = sizeCache.get(key);\n            const size: CellSize = [\n              contentRect[heightKey],\n              contentRect[widthKey],\n            ];\n            let rowResized: boolean | undefined;\n            let colResized: boolean | undefined;\n            if (!prevSize) {\n              rowResized = colResized = true;\n            } else {\n              if (prevSize[0] !== size[0]) {\n                rowResized = true;\n              }\n              if (prevSize[1] !== size[1]) {\n                colResized = true;\n              }\n            }\n            if (rowResized) {\n              resizedRows.add(rowIndex);\n            }\n            if (colResized) {\n              resizedCols.add(colIndex);\n            }\n            if (rowResized || colResized) {\n              sizeCache.set(key, size);\n            }\n          }\n        }\n      }\n\n      if (resizedRows.size) {\n        const heightResizes: ItemResize[] = [];\n        resizedRows.forEach((rowIndex) => {\n          let maxHeight = 0;\n          maybeCachedColIndexes.forEach((colIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxHeight = max(maxHeight, size[0]);\n            }\n          });\n          if (maxHeight) {\n            heightResizes.push([rowIndex, maxHeight]);\n          }\n        });\n        vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n      }\n      if (resizedCols.size) {\n        const widthResizes: ItemResize[] = [];\n        resizedCols.forEach((colIndex) => {\n          let maxWidth = 0;\n          maybeCachedRowIndexes.forEach((rowIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxWidth = max(maxWidth, size[1]);\n            }\n          });\n          if (maxWidth) {\n            widthResizes.push([colIndex, maxWidth]);\n          }\n        });\n        hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","import {\n  CSSProperties,\n  ReactElement,\n  ReactNode,\n  forwardRef,\n  useMemo,\n} from \"react\";\n\nexport type WindowComponentAttributes = Pick<\n  React.HTMLAttributes<HTMLElement>,\n  \"className\" | \"style\" | \"id\" | \"role\" | \"tabIndex\"\n> &\n  React.AriaAttributes;\n\n/**\n * Props of customized scrollable component.\n */\nexport interface CustomWindowComponentProps {\n  /**\n   * Renderable item elements.\n   */\n  children: ReactNode;\n  /**\n   * Attributes that should be passed to the scrollable element.\n   */\n  attrs: WindowComponentAttributes;\n  /**\n   * Total height of items. It's undefined if component is not vertically scrollable.\n   */\n  height: number | undefined;\n  /**\n   * Total width of items. It's undefined if component is not horizontally scrollable.\n   */\n  width: number | undefined;\n  /**\n   * Currently component is scrolling or not.\n   */\n  scrolling: boolean;\n}\n\nexport const Window = forwardRef<any, CustomWindowComponentProps>(\n  ({ children, attrs, width, height, scrolling }, ref): ReactElement => {\n    return (\n      <div ref={ref} {...attrs}>\n        <div\n          style={useMemo((): CSSProperties => {\n            return {\n              position: \"relative\",\n              visibility: \"hidden\",\n              width: width ?? \"100%\",\n              height: height ?? \"100%\",\n              pointerEvents: scrolling ? \"none\" : \"auto\",\n            };\n          }, [width, height, scrolling])}\n        >\n          {children}\n        </div>\n      </div>\n    );\n  }\n);\n\nexport type CustomWindowComponent = typeof Window;\n"],"names":["min","max","abs","now","values","timeout","exists","v","range","length","cb","_","i","median","arr","s","a","b","mid","debounce","fn","ms","id","cancel","debouncedFn","throttle","time","args","n","once","called","cache","UNCACHED","getItemSize","index","size","setItemSize","isInitialMeasurement","computeOffset","isTotal","top","computeTotalSize","computeStartOffset","findIndex","distance","sum","h","findStartIndexWithOffset","offset","prevStartIndex","prevOffset","hasUnmeasuredItemsInRange","startIndex","endIndex","estimateDefaultItemSize","measuredSizes","startItemSize","resetCache","itemSize","sumJumps","jump","acc","j","calculateJumps","items","SUBPIXEL_THRESHOLD","SCROLL_IDLE","SCROLL_DOWN","SCROLL_UP","SCROLL_MANUAL","ACTION_ITEM_RESIZE","ACTION_WINDOW_RESIZE","ACTION_SCROLL","ACTION_MANUAL_SCROLL","ACTION_SCROLL_END","UPDATE_SCROLL","UPDATE_SIZE","UPDATE_JUMP","createVirtualStore","elementsCount","initialItemCount","isReverse","onScrollStateChange","onScrollOffsetChange","shouldAutoEstimateItemSize","initialItemSize","viewportSize","scrollOffset","jumpCount","_scrollDirection","_resized","_prevRange","subscribers","getScrollSize","getScrollOffsetMax","flushIsJustResized","prev","updateScrollDirection","dir","prevEndIndex","start","end","findEndIndex","prevJump","target","sub","type","payload","shouldSync","updatedScrollState","mutated","updated","diff","allJumps","isNewItemMeasured","isJustResized","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","refKey","flattenChildren","children","Children","e","useRefWithUpdate","value","ref","useRef","useSelector","store","getSnapShot","shouldGetLatest","state","setState","useState","getter","update","sync","flushSync","snap","hasNegativeOffsetInRtl","scrollable","key","isNegative","createOnWheel","isHorizontal","onScrollStopped","createScroller","isRtl","rootElement","scrollToQueue","scrollToKey","getActualScrollSize","normalizeOffset","scrollManually","getCurrentOffset","getOffset","unsubscribe","resolve","reject","resolved","resolveQueue","root","syncViewportToScrollPosition","onScroll","onWheel","createWindowScroller","offsetKey","visible","getOffsetToWindow","node","nodeOffset","parent","io","entry","useStatic","init","createResizer","sizeKey","mountedIndexes","getResizeObserver","entries","resizes","contentRect","ro","el","createWindowResizer","windowSizeKey","createGridResizer","vStore","hStore","heightKey","widthKey","maybeCachedRowIndexes","maybeCachedColIndexes","sizeCache","getKey","rowIndex","colIndex","resizedRows","resizedCols","cell","prevSize","rowResized","colResized","heightResizes","maxHeight","widthResizes","maxWidth","Window","forwardRef","attrs","width","height","scrolling","jsx","useMemo"],"mappings":"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"}