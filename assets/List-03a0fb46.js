import{j as k}from"./jsx-runtime-6c4ce591.js";import{r as m}from"./index-fcd6345f.js";const x=Math.min,U=Math.max,ge=Math.abs,Q=Date.now,P=e=>e!=null,Z=(e,t)=>Array.from({length:e},(n,r)=>t(r)),ve=(e,t)=>{let n;const r=()=>{P(n)&&clearTimeout(n)},o=()=>{r(),n=setTimeout(()=>{n=null,e()},t)};return o._cancel=r,o},Ie=(e,t)=>{let n=Q()-t;return(...r)=>{const o=Q();n+t<o&&(n=o,e(...r))}},N=-1,H=(e,t)=>{const n=e._sizes[t];return n===N?e._defaultItemSize:n},we=(e,t,n)=>{e._sizes[t]=n,e._measuredOffsetIndex=x(t,e._measuredOffsetIndex)},le=(e,t,n)=>{if(!e._length)return 0;if(e._measuredOffsetIndex>=t)return n?e._offsets[t]+H(e,t):e._offsets[t];let r=e._measuredOffsetIndex,o=e._offsets[r];for(;r<=t&&(e._offsets[r]=o,!(r===t&&!n));)o+=H(e,r),r++;return e._measuredOffsetIndex=t,o},ye=e=>le(e,e._length-1,!0),B=(e,t)=>le(e,t),ie=(e,t,n)=>{let r=0;if(n>=0)for(;t<e._length-1;){const o=H(e,t++);if((r+=o)>=n){r-o/2>=n&&t--;break}}else for(;t>0;){const o=H(e,--t);if((r-=o)<=n){r+o/2<n&&t++;break}}return x(U(t,0),e._length-1)},$=(e,t,n,r)=>ie(e,n,t-r),ee=ie,ze=(e,t,n)=>{for(let r=t;r<=n;r++)if(e._sizes[r]===N)return!0;return!1},te=(e,t,n)=>({_defaultItemSize:t,_length:e,_measuredOffsetIndex:n?x(n._measuredOffsetIndex,e-1):0,_sizes:Z(e,r=>{const o=n&&n._sizes[r];return P(o)?o:N}),_offsets:Z(e,r=>{if(r===0)return 0;const o=n&&n._offsets[r];return P(o)?o:N})}),ue=0,K=1,ce=2,j=3,be=(e,t,n,r)=>{let o=0,_=0,S=0,u=[],l=te(e,t),y=[0,0],I;const z=new Set,R=()=>n?o:_;return{_getRange(){const[i,p]=y,f=B(l,i),w=$(l,S,i,f),s=ee(l,w,R());return i===w&&p===s?y:y=[w,s]},_isUnmeasuredItem(i){return l._sizes[i]===N},_hasUnmeasuredItemsInRange(i){return ze(l,i,ee(l,i,R()))},_getItemOffset(i){return B(l,i)},_getScrollOffset(){return S},_getViewportSize(){return R()},_getScrollSize(){return ye(l)},_getItemCount(){return l._length},_getJump(){return u},_isHorizontal(){return n},_isRtl(){return r},_getItemIndexForScrollTo(i){return $(l,i,0,0)},_waitForScrollDestinationItemsMeasured(){return I&&I[1](),new Promise((i,p)=>{I=[()=>{Promise.resolve().then(()=>{i(),I=void 0})},p]})},_subscribe(i){return z.add(i),()=>{z.delete(i)}},_update(i,p){(()=>{switch(i){case ue:return l._length===p?!1:(l=te(p,t,l),!0);case K:{const w=p.filter(([a,c])=>l._sizes[a]!==c);if(!w.length)return!1;const s=[];return w.forEach(([a,c])=>{s.push([a,c-H(l,a)]),we(l,a,c)}),u=s,!0}case ce:return o===p._width&&_===p._height?!1:(o=p._width,_=p._height,!0);case j:{const w=S;return(S=p)!==w}}})()&&(z.forEach(w=>{w()}),I&&i===K&&I[0]())}}},M=typeof window<"u"?m.useLayoutEffect:m.useEffect;var J={},Ee={get exports(){return J},set exports(e){J=e}},ae={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var D=m;function Re(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Oe=typeof Object.is=="function"?Object.is:Re,Ce=D.useState,Te=D.useEffect,Le=D.useLayoutEffect,Ve=D.useDebugValue;function xe(e,t){var n=t(),r=Ce({inst:{value:n,getSnapshot:t}}),o=r[0].inst,_=r[1];return Le(function(){o.value=n,o.getSnapshot=t,F(o)&&_({inst:o})},[e,n,t]),Te(function(){return F(o)&&_({inst:o}),e(function(){F(o)&&_({inst:o})})},[e]),Ve(n),n}function F(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Oe(e,n)}catch{return!0}}function ke(e,t){return t()}var Pe=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?ke:xe;ae.useSyncExternalStore=D.useSyncExternalStore!==void 0?D.useSyncExternalStore:Pe;(function(e){e.exports=ae})(Ee);const W=(e,t)=>J.useSyncExternalStore(e,t,t),A=0,De=1,fe=2,Y=3,Ae=(e,t,n)=>{let r=-1,o=A,_=!1,S,u,l;const y=e._isHorizontal(),I=e._isRtl(),z=y?"scrollLeft":"scrollTop",R=new WeakMap,i=()=>l||(l=new ResizeObserver(s=>{const a=[];for(const c of s)if(c.target===u)e._update(ce,{_width:c.contentRect.width,_height:c.contentRect.height});else{const h=R.get(c.target);P(h)&&a.push([h,c.contentRect[y?"width":"height"]])}a.length&&(e._update(K,a),_=!0)})),p=()=>u?e._isHorizontal()?u.scrollWidth:u.scrollHeight:0,f=(s,a)=>{if(u){if(I){if(!P(S)){const c=u[z];u[z]=1,S=u[z]===0,u[z]=c}S&&(s*=-1)}a?u[z]+=s:(u[z]=s,o=Y)}};return{_initRoot(s){u=s;const a=i(),c=()=>{let v=s[z];I&&(v=ge(v)),r!==v&&(o===A||!_?o!==Y&&(o=r>v?fe:De):_=!1,e._update(j,r=v),t(v))},h=ve(()=>{c(),o=A,n(!1)},150),C=()=>{const v=o===A;c(),v&&n(!0),h()},T=Ie(v=>{o!==A&&(v.ctrlKey||(y?v.deltaX:v.deltaY)&&r>0&&r<e._getScrollSize()-e._getViewportSize()&&h())},50);return a.observe(s),s.addEventListener("scroll",C),s.addEventListener("wheel",T,{passive:!0}),()=>{a.disconnect(),s.removeEventListener("scroll",C),s.removeEventListener("wheel",T),h._cancel()}},_initItem(s,a){const c=i();return R.set(s,a),c.observe(s),()=>{R.delete(s),c.unobserve(s)}},_getScrollDirection(){return o},_getActualScrollSize:p,_updateScrollPosition:f,_scrollTo:async(s,a)=>{const c=()=>{let h=a();const C=p(),T=e._getViewportSize();return C-(h+T)<=0&&(h=C-T),h};if(e._hasUnmeasuredItemsInRange(s)){do{e._update(j,c());try{await e._waitForScrollDestinationItemsMeasured()}catch{return}}while(e._hasUnmeasuredItemsInRange(s));f(c())}else{const h=c();f(h),e._update(j,h)}}}},b="current",ne=e=>{const t=m.useRef();return t[b]||(t[b]=e())},re=e=>{const t=m.useRef(e);return M(()=>{t[b]=e}),m.useCallback((...n)=>{t[b]&&t[b](...n)},[])},oe=-1,Me=m.memo(({_children:e,_scroller:t,_store:n,_index:r,_element:o})=>{const _=m.useRef(null),S=W(n._subscribe,()=>n._getItemOffset(r)),u=W(n._subscribe,()=>n._isUnmeasuredItem(r));return M(()=>t._initItem(_[b],r),[r]),k(o,{ref:_,style:m.useMemo(()=>{const l=n._isHorizontal(),y=n._isRtl()?"right":"left",I={margin:0,padding:0,position:"absolute",[l?"height":"width"]:"100%",[l?"top":y]:0,[l?y:"top"]:S};return l&&(I.display="flex"),u&&(I.visibility="hidden"),I},[S,u]),children:e})}),Ne=e=>!P(e)||typeof e=="boolean",He=m.forwardRef(({children:e,style:t,scrollSize:n,scrolling:r,horizontal:o,rtl:_},S)=>k("div",{ref:S,style:t,children:k("div",{style:m.useMemo(()=>{const u=o?n:"100%",l=o?"100%":n;return{position:"absolute",top:0,[_?"right":"left"]:0,width:u,height:l,minWidth:u,minHeight:l,pointerEvents:r?"none":"auto"}},[n,r]),children:e})})),We=({_children:e,_ref:t,_store:n,_element:r,_scrolling:o,_style:_})=>{const S=W(n._subscribe,n._getScrollSize),u=n._isHorizontal();return k(r,{ref:t,scrollSize:S,scrolling:o,horizontal:u,rtl:n._isRtl(),style:m.useMemo(()=>({overflow:u?"auto hidden":"hidden auto",position:"relative",contain:"strict",width:"100%",height:"100%",padding:0,margin:0,..._}),[_]),children:e})},se=m.forwardRef(({children:e,itemSize:t=40,overscan:n=4,horizontal:r,rtl:o,endThreshold:_=0,style:S,element:u=He,itemElement:l="div",onEndReached:y,onScroll:I,onScrollStop:z},R)=>{const i=m.useMemo(()=>{const d=[];return m.Children.forEach(e,g=>{Ne(g)||d.push(g)}),d},[e]),p=i.length,f=ne(()=>be(p,t,!!r,!!o)),[w,s]=W(f._subscribe,f._getRange),a=W(f._subscribe,f._getJump),c=m.useRef(null),h=m.useRef(oe),C=re(I),T=re(z),[v,de]=m.useState(new Set),[me,_e]=m.useState(!1),O=ne(()=>Ae(f,C,d=>{_e(d),d||(de(new Set),T())})),L=x(p,f._getItemCount());M(()=>{f._update(ue,p)},[p]),M(()=>O._initRoot(c[b]),[]),M(()=>{if(!a.length)return;const d=O._getScrollDirection();if(d===fe){const g=a.reduce((E,[,V])=>E+V,0);g&&O._updateScrollPosition(g,!0)}else if(d===Y){const g=f._getScrollOffset();if(g!==0){const E=a.reduce((V,[,q])=>V+q,0);if(f._getScrollSize()-(g+f._getViewportSize()+E)<=0)E&&O._updateScrollPosition(g+E);else{const V=a.reduce((q,[he,Se])=>(he<w&&(q+=Se),q),0);V&&O._updateScrollPosition(V,!0)}}}},[a]),m.useEffect(()=>{if(!y)return;h[b]>L&&(h[b]=oe),L-1-s<=_&&h[b]<L&&(h[b]=L,y())},[s]),m.useImperativeHandle(R,()=>({get scrollOffset(){return f._getScrollOffset()},get scrollSize(){return O._getActualScrollSize()},scrollToIndex(d){d=U(x(d,L-1),0),O._scrollTo(d,()=>f._getItemOffset(d))},scrollToOffset(d){d=U(d,0),O._scrollTo(f._getItemIndexForScrollTo(d),()=>d)}}),[L]);const X=U(w-n,0),G=x(s+n,L-1),pe=m.useMemo(()=>{const d=[];for(let g=X;g<=G;g++)v.add(g);return v.forEach(g=>{const E=i[g];d.push(k(Me,{_scroller:O,_store:f,_index:g,_element:l,_children:E},(E==null?void 0:E.key)||g))}),d},[i,v,X,G]);return k(We,{_ref:c,_store:f,_element:u,_scrolling:me,_style:S,_children:pe})});try{se.displayName="List",se.__docgenInfo={description:"Virtualized list component. See {@link ListProps} and {@link ListHandle}.",displayName:"List",props:{children:{defaultValue:null,description:"Elements rendered by this component.",name:"children",required:!0,type:{name:"ReactNode"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.
@defaultValue 40`,name:"itemSize",required:!1,type:{name:"number"}},overscan:{defaultValue:{value:"4"},description:`Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.
@defaultValue 4`,name:"overscan",required:!1,type:{name:"number"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean"}},rtl:{defaultValue:null,description:"You have to set true if you use this component under `direction: rtl` style.",name:"rtl",required:!1,type:{name:"boolean"}},endThreshold:{defaultValue:{value:"0"},description:`Number of items to be the margin from the end of the scroll. See also {@link onEndReached}.
@defaultValue 0`,name:"endThreshold",required:!1,type:{name:"number"}},style:{defaultValue:null,description:"Inline style prop to override style of scrollable element.",name:"style",required:!1,type:{name:"CSSProperties"}},element:{defaultValue:{value:`forwardRef<any, CustomWindowComponentProps>(
  (
    { children, style, scrollSize, scrolling, horizontal, rtl },
    ref
  ): ReactElement => {
    return (
      <div ref={ref} style={style}>
        <div
          style={useMemo((): CSSProperties => {
            const width = horizontal ? scrollSize : "100%";
            const height = horizontal ? "100%" : scrollSize;
            return {
              position: "absolute",
              top: 0,
              [rtl ? "right" : "left"]: 0,
              width,
              height,
              minWidth: width,
              minHeight: height,
              pointerEvents: scrolling ? "none" : "auto",
            };
          }, [scrollSize, scrolling])}
        >
          {children}
        </div>
      </div>
    );
  }
)`},description:`Customized element type for scrollable element. This element will get {@link CustomWindowComponentProps} as props.
@defaultValue {@link DefaultWindow }`,name:"element",required:!1,type:{name:"ForwardRefExoticComponent<CustomWindowComponentProps & RefAttributes<any>>"}},itemElement:{defaultValue:{value:"div"},description:`Customized element type for item element. This element will get {@link CustomItemComponentProps} as props.
@defaultValue "div"`,name:"itemElement",required:!1,type:{name:"CustomItemComponentOrElement"}},onEndReached:{defaultValue:null,description:"Callback invoked when scrolling reached to the end. The margin from the end is specified by {@link endThreshold}.",name:"onEndReached",required:!1,type:{name:"() => void"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop or scrollLeft.`,name:"onScroll",required:!1,type:{name:"(offset: number) => void"}},onScrollStop:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollStop",required:!1,type:{name:"() => void"}}}}}catch{}export{se as L};
//# sourceMappingURL=List-03a0fb46.js.map
