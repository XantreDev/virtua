{"version":3,"file":"resizer-legacy-ffe6a524.js","sources":["../../src/core/utils.ts","../../src/core/cache.ts","../../src/core/dom.ts","../../src/core/store.ts","../../src/react/useIsomorphicLayoutEffect.ts","../../src/react/useSyncExternalStore.ts","../../src/react/utils.ts","../../src/core/scroller.ts","../../src/react/useStatic.ts","../../src/core/resizer.ts"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const now = Date.now;\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const range = <T>(length: number, cb: (i: number) => T): T[] =>\n  Array.from({ length }, (_, i) => cb(i));\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: NodeJS.Timeout | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = setTimeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { exists, max, min, range } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _measuredOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n) => {\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._measuredOffsetIndex = min(index, cache._measuredOffsetIndex);\n};\n\nconst computeOffset = (\n  cache: Writeable<Cache>,\n  index: number,\n  isTotal?: boolean\n): number => {\n  if (!cache._length) return 0;\n  if (cache._measuredOffsetIndex >= index) {\n    if (isTotal) {\n      return cache._offsets[index]! + getItemSize(cache, index);\n    } else {\n      return cache._offsets[index]!;\n    }\n  }\n\n  let i = cache._measuredOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i <= index) {\n    cache._offsets[i] = top;\n    if (i === index && !isTotal) {\n      break;\n    }\n    top += getItemSize(cache, i);\n    i++;\n  }\n  // mark as measured\n  cache._measuredOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  return computeOffset(cache, cache._length - 1, true);\n};\n\nexport const computeStartOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  return computeOffset(cache, index);\n};\n\nconst findIndex = (cache: Cache, i: number, distance: number): number => {\n  let sum = 0;\n  if (distance >= 0) {\n    // search forward\n    while (i < cache._length - 1) {\n      const h = getItemSize(cache, i++);\n      if ((sum += h) >= distance) {\n        if (sum - h / 2 >= distance) {\n          i--;\n        }\n        break;\n      }\n    }\n  } else {\n    // search backward\n    while (i > 0) {\n      const h = getItemSize(cache, --i);\n      if ((sum -= h) <= distance) {\n        if (sum + h / 2 < distance) {\n          i++;\n        }\n        break;\n      }\n    }\n  }\n\n  return min(max(i, 0), cache._length - 1);\n};\n\nexport const findStartIndexWithOffset = (\n  cache: Cache,\n  offset: number,\n  prevStartIndex: number,\n  prevOffset: number\n): number => {\n  return findIndex(cache, prevStartIndex, offset - prevOffset);\n};\n\nexport const findEndIndex = findIndex;\n\nexport const hasUnmeasuredItemsInRange = (\n  cache: Cache,\n  startIndex: number,\n  endIndex: number\n): boolean => {\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (cache._sizes[i] === UNCACHED) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const resetCache = (\n  length: number,\n  itemSize: number,\n  cache?: Cache\n): Cache => {\n  return {\n    _defaultItemSize: itemSize,\n    _length: length,\n    _measuredOffsetIndex: cache\n      ? min(cache._measuredOffsetIndex, length - 1)\n      : 0,\n    _sizes: range(length, (i) => {\n      const size = cache && cache._sizes[i];\n      if (exists(size)) {\n        return size;\n      }\n      return UNCACHED;\n    }),\n    _offsets: range(length, (i) => {\n      if (i === 0) {\n        // first offset must be 0\n        return 0;\n      }\n      const offset = cache && cache._offsets[i];\n      if (exists(offset)) {\n        return offset;\n      }\n      return UNCACHED;\n    }),\n  };\n};\n","import { once } from \"./utils\";\n\n// The scroll position may be negative value in rtl direction.\n// https://github.com/othree/jquery.rtl-scroll-type\nexport const hasNegativeOffsetInRtl = once((scrollable: HTMLElement) => {\n  const key = \"scrollLeft\";\n  const prev = scrollable[key];\n  scrollable[key] = 1;\n  // scrollLeft can be positive under some specific situations even if negative mode, so we use `<` for now.\n  const isNegative = scrollable[key] < 1;\n  scrollable[key] = prev;\n  return isNegative;\n});\n","import {\n  findStartIndexWithOffset,\n  resetCache,\n  getItemSize,\n  computeTotalSize,\n  findEndIndex,\n  computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  hasUnmeasuredItemsInRange,\n} from \"./cache\";\nimport type { Writeable } from \"./types\";\nimport { max } from \"./utils\";\n\ntype ItemJump = [sizeDiff: number, index: number];\nexport type ScrollJump = Readonly<ItemJump[]>;\nexport type ItemResize = [index: number, size: number];\ntype ItemsRange = [startIndex: number, endIndex: number];\n\nexport const SCROLL_STOP = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\nexport const SCROLL_MANUAL = 3;\ntype ScrollDirection =\n  | typeof SCROLL_STOP\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP\n  | typeof SCROLL_MANUAL;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_WINDOW_RESIZE = 2;\nexport const ACTION_SCROLL = 3;\nexport const ACTION_MANUAL_SCROLL = 4;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_WINDOW_RESIZE, size: number]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, offset: number];\n\nexport type VirtualStore = {\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInRange(startIndex: number): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getScrollOffset(): number;\n  _getViewportSize(): number;\n  _getScrollSize(): number;\n  _getJump(): ScrollJump;\n  _isHorizontal(): boolean;\n  _isRtl(): boolean;\n  _getItemIndexForScrollTo(offset: number): number;\n  _waitForScrollDestinationItemsMeasured(): Promise<void>;\n  _subscribe(cb: () => void): () => void;\n  _update(...action: Actions): void;\n  _getScrollDirection(): ScrollDirection;\n  _setScrollDirection(direction: ScrollDirection): void;\n  _updateCacheLength(length: number): void;\n};\n\nexport const createVirtualStore = (\n  itemCount: number,\n  itemSize: number,\n  isHorizontal: boolean,\n  isRtl: boolean,\n  initialItemCount: number = 0,\n  onScrollStateChange: (scrolling: boolean) => void,\n  onScrollOffsetChange: (offset: number) => void\n): VirtualStore => {\n  let viewportSize = itemSize * max(initialItemCount - 1, 0);\n  let scrollOffset = 0;\n  let jump: ItemJump[] = [];\n  let cache = resetCache(itemCount, itemSize);\n  let scrollDirection: ScrollDirection = SCROLL_STOP;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n  let _scrollToQueue: [() => void, () => void] | undefined;\n\n  const subscribers = new Set<() => void>();\n\n  return {\n    _getRange() {\n      const [prevStartIndex, prevEndIndex] = _prevRange;\n      const prevOffset = computeStartOffset(\n        cache as Writeable<Cache>,\n        prevStartIndex\n      );\n      const start = findStartIndexWithOffset(\n        cache,\n        scrollOffset,\n        prevStartIndex,\n        prevOffset\n      );\n      const end = findEndIndex(cache, start, viewportSize);\n      if (prevStartIndex === start && prevEndIndex === end) {\n        return _prevRange;\n      }\n      return (_prevRange = [start, end]);\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInRange(startIndex) {\n      return hasUnmeasuredItemsInRange(\n        cache,\n        startIndex,\n        findEndIndex(cache, startIndex, viewportSize)\n      );\n    },\n    _getItemOffset(index) {\n      return computeStartOffset(cache as Writeable<Cache>, index);\n    },\n    _getItemSize(index) {\n      return getItemSize(cache, index);\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getScrollSize() {\n      return computeTotalSize(cache as Writeable<Cache>);\n    },\n    _getJump() {\n      return jump;\n    },\n    _isHorizontal() {\n      return isHorizontal;\n    },\n    _isRtl() {\n      return isRtl;\n    },\n    _getItemIndexForScrollTo(offset) {\n      return findStartIndexWithOffset(cache, offset, 0, 0);\n    },\n    _waitForScrollDestinationItemsMeasured() {\n      if (_scrollToQueue) {\n        // Cancel waiting scrollTo\n        _scrollToQueue[1]();\n      }\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      // For example, ResizeObserver may not fire when window is not visible.\n      return new Promise((resolve, reject) => {\n        _scrollToQueue = [\n          () => {\n            // HACK: It should be resolved in the next microtask that is after React's render\n            Promise.resolve().then(() => {\n              resolve();\n              _scrollToQueue = undefined;\n            });\n          },\n          reject,\n        ];\n      });\n    },\n    _subscribe(cb) {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    _update(type, payload) {\n      const mutated = ((): boolean => {\n        switch (type) {\n          case ACTION_ITEM_RESIZE: {\n            const updated = payload.filter(\n              ([index, size]) => cache._sizes[index] !== size\n            );\n            // Skip if all items are cached and not updated\n            if (!updated.length) {\n              return false;\n            }\n\n            const updatedJump: ItemJump[] = [];\n            updated.forEach(([index, size]) => {\n              updatedJump.push([size - getItemSize(cache, index), index]);\n              setItemSize(cache as Writeable<Cache>, index, size);\n            });\n            jump = updatedJump;\n            return true;\n          }\n          case ACTION_WINDOW_RESIZE: {\n            if (viewportSize === payload) {\n              return false;\n            }\n            viewportSize = payload;\n            return true;\n          }\n          case ACTION_SCROLL:\n          case ACTION_MANUAL_SCROLL: {\n            const prevOffset = scrollOffset;\n            return (scrollOffset = payload) !== prevOffset;\n          }\n        }\n      })();\n\n      if (mutated) {\n        subscribers.forEach((cb) => {\n          cb();\n        });\n\n        if (type === ACTION_SCROLL) {\n          onScrollOffsetChange(scrollOffset);\n        } else if (_scrollToQueue && type === ACTION_ITEM_RESIZE) {\n          _scrollToQueue[0]();\n        }\n      }\n    },\n    _getScrollDirection() {\n      return scrollDirection;\n    },\n    _setScrollDirection(dir) {\n      const prev = scrollDirection;\n      scrollDirection = dir;\n      if (scrollDirection === SCROLL_STOP) {\n        onScrollStateChange(false);\n      } else if (\n        prev === SCROLL_STOP &&\n        (scrollDirection === SCROLL_DOWN || scrollDirection === SCROLL_UP)\n      ) {\n        onScrollStateChange(true);\n      }\n    },\n    _updateCacheLength(length) {\n      // It's ok to be updated in render because states should be calculated consistently regardless cache length\n      if (cache._length === length) return;\n      cache = resetCache(length, itemSize, cache);\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { useSyncExternalStore as _useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nexport const useSyncExternalStore = <T>(\n  subscibe: (onStoreChange: () => void) => () => void,\n  getSnapShot: () => T\n): T => {\n  return _useSyncExternalStore(subscibe, getSnapShot, getSnapShot);\n};\n","import { ReactNode } from \"react\";\nimport { exists } from \"../core/utils\";\n\nexport const refKey = \"current\";\n\nexport const isInvalidElement = <T extends ReactNode>(\n  e: T\n): e is Extract<T, null | undefined | boolean> =>\n  !exists(e) || typeof e === \"boolean\";\n","import { hasNegativeOffsetInRtl } from \"./dom\";\nimport {\n  ACTION_SCROLL,\n  ACTION_MANUAL_SCROLL,\n  ScrollJump,\n  VirtualStore,\n  SCROLL_MANUAL,\n  SCROLL_STOP,\n  SCROLL_UP,\n  SCROLL_DOWN,\n} from \"./store\";\nimport { debounce, throttle, max, min } from \"./utils\";\n\nexport type Scroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _getActualScrollSize: () => number;\n  _scrollTo: (offset: number) => void;\n  _scrollToIndex: (index: number, count: number) => void;\n  _fixScrollJump: (jump: ScrollJump, startIndex: number) => void;\n};\n\nexport const createScroller = (\n  store: VirtualStore,\n  isJustResized: () => boolean\n): Scroller => {\n  let rootElement: HTMLElement | undefined;\n  const isHorizontal = store._isHorizontal();\n  const isRtl = store._isRtl();\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n\n  const getActualScrollSize = (): number => {\n    if (!rootElement) return 0;\n    // Use element's scrollHeight/scrollWidth instead of stored scrollSize.\n    // This is because stored size may differ from the actual size, for example when a new item is added and not yet measured.\n    return isHorizontal ? rootElement.scrollWidth : rootElement.scrollHeight;\n  };\n  const scrollTo = (offset: number, diff?: boolean) => {\n    if (!rootElement) return;\n    if (isHorizontal && isRtl) {\n      if (hasNegativeOffsetInRtl(rootElement)) {\n        offset *= -1;\n      }\n    }\n    if (diff) {\n      rootElement[scrollToKey] += offset;\n    } else {\n      rootElement[scrollToKey] = offset;\n      store._setScrollDirection(SCROLL_MANUAL);\n    }\n  };\n  const scrollManually = async (\n    index: number,\n    getCurrentOffset: () => number\n  ) => {\n    const getOffset = (): number => {\n      let offset = getCurrentOffset();\n      const scrollSize = getActualScrollSize();\n      const viewportSize = store._getViewportSize();\n      if (scrollSize - (offset + viewportSize) <= 0) {\n        // Adjust if the offset is over the end, to get correct startIndex.\n        offset = scrollSize - viewportSize;\n      }\n      return offset;\n    };\n\n    if (store._hasUnmeasuredItemsInRange(index)) {\n      do {\n        // In order to scroll to the correct position, mount the items and measure their sizes before scrolling.\n        store._update(ACTION_MANUAL_SCROLL, getOffset());\n        try {\n          // Wait for the scroll destination items to be measured.\n          await store._waitForScrollDestinationItemsMeasured();\n        } catch (e) {\n          // canceled\n          return;\n        }\n      } while (store._hasUnmeasuredItemsInRange(index));\n\n      // Scroll with the updated value\n      scrollTo(getOffset());\n    } else {\n      const offset = getOffset();\n      scrollTo(offset);\n      // Sync viewport to scroll destination\n      store._update(ACTION_MANUAL_SCROLL, offset);\n    }\n  };\n\n  const calcTotalJump = (jump: ScrollJump): number =>\n    jump.reduce((acc, [j]) => acc + j, 0);\n\n  return {\n    _initRoot(root) {\n      rootElement = root;\n\n      const syncViewportToScrollPosition = () => {\n        let offset = root[scrollToKey];\n        if (isHorizontal && isRtl) {\n          if (hasNegativeOffsetInRtl(root)) {\n            offset *= -1;\n          }\n        }\n        const prevOffset = store._getScrollOffset();\n        if (prevOffset === offset) {\n          return;\n        }\n        const scrollDirection = store._getScrollDirection();\n        // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n        // Scroll events are dispatched enough so it's ok to skip some of them.\n        const resized = isJustResized();\n        if (\n          (scrollDirection === SCROLL_STOP || !resized) &&\n          // Ignore until manual scrolling\n          scrollDirection !== SCROLL_MANUAL\n        ) {\n          store._setScrollDirection(\n            prevOffset > offset ? SCROLL_UP : SCROLL_DOWN\n          );\n        }\n        store._update(ACTION_SCROLL, offset);\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._setScrollDirection(SCROLL_STOP);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      // Infer scroll state also from wheel events\n      // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n      const onWheel = throttle((e: WheelEvent) => {\n        if (store._getScrollDirection() === SCROLL_STOP) {\n          // Scroll start should be detected with scroll event\n          return;\n        }\n        if (e.ctrlKey) {\n          // Probably a pinch-to-zoom gesture\n          return;\n        }\n        // Get delta before checking deltaMode for firefox behavior\n        // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n        if (isHorizontal ? e.deltaX : e.deltaY) {\n          const offset = store._getScrollOffset();\n          if (\n            offset > 0 &&\n            offset < store._getScrollSize() - store._getViewportSize()\n          ) {\n            onScrollStopped();\n          }\n        }\n      }, 50);\n\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _getActualScrollSize: getActualScrollSize,\n    _scrollTo(offset) {\n      offset = max(offset, 0);\n\n      scrollManually(store._getItemIndexForScrollTo(offset), () => offset);\n    },\n    _scrollToIndex(index, count) {\n      index = max(min(index, count - 1), 0);\n\n      scrollManually(index, () => store._getItemOffset(index));\n    },\n    _fixScrollJump: (jump, startIndex) => {\n      const scrollDirection = store._getScrollDirection();\n      // Compensate scroll jump\n      if (scrollDirection === SCROLL_UP) {\n        const diff = calcTotalJump(jump);\n        if (diff) {\n          scrollTo(diff, true);\n        }\n      } else if (scrollDirection === SCROLL_MANUAL) {\n        const offset = store._getScrollOffset();\n        if (offset === 0) {\n          // Do nothing to stick to the start\n        } else {\n          const allDiff = calcTotalJump(jump);\n          if (\n            store._getScrollSize() -\n              (offset + store._getViewportSize() + allDiff) <=\n            0\n          ) {\n            // Keep end to stick to the end\n            if (allDiff) {\n              scrollTo(offset + allDiff);\n            }\n          } else {\n            // Keep start at mid\n            const diff = jump.reduce((acc, [j, index]) => {\n              if (index < startIndex) {\n                acc += j;\n              }\n              return acc;\n            }, 0);\n            if (diff) {\n              scrollTo(diff, true);\n            }\n          }\n        }\n      } else {\n        // NOP\n      }\n    },\n  };\n};\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import {\n  ACTION_ITEM_RESIZE,\n  ACTION_WINDOW_RESIZE,\n  ItemResize,\n  VirtualStore,\n} from \"./store\";\nimport { exists, max, once } from \"./utils\";\n\nexport const createResizer = (store: VirtualStore) => {\n  let resized = false;\n  let rootElement: HTMLElement | undefined;\n  const sizeKey = store._isHorizontal() ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          store._update(ACTION_WINDOW_RESIZE, contentRect[sizeKey]);\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n        resized = true;\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _isJustResized(): boolean {\n      const prev = resized;\n      resized = false;\n      return prev;\n    },\n  };\n};\n\nexport type Resizer = ReturnType<typeof createResizer>;\n\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let heightResized = false;\n  let widthResized = false;\n  let rootElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizedRows = new Set<number>();\n      const resizedCols = new Set<number>();\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          vStore._update(ACTION_WINDOW_RESIZE, contentRect[heightKey]);\n          hStore._update(ACTION_WINDOW_RESIZE, contentRect[widthKey]);\n        } else {\n          const cell = mountedIndexes.get(target);\n          if (cell) {\n            const [rowIndex, colIndex] = cell;\n            const key = getKey(rowIndex, colIndex);\n            const prevSize = sizeCache.get(key);\n            const size: CellSize = [\n              contentRect[heightKey],\n              contentRect[widthKey],\n            ];\n            let rowResized: boolean | undefined;\n            let colResized: boolean | undefined;\n            if (!prevSize) {\n              rowResized = colResized = true;\n            } else {\n              if (prevSize[0] !== size[0]) {\n                rowResized = true;\n              }\n              if (prevSize[1] !== size[1]) {\n                colResized = true;\n              }\n            }\n            if (rowResized) {\n              resizedRows.add(rowIndex);\n            }\n            if (colResized) {\n              resizedCols.add(colIndex);\n            }\n            if (rowResized || colResized) {\n              sizeCache.set(key, size);\n            }\n          }\n        }\n      }\n\n      if (resizedRows.size) {\n        const heightResizes: ItemResize[] = [];\n        resizedRows.forEach((rowIndex) => {\n          let maxHeight = 0;\n          maybeCachedColIndexes.forEach((colIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxHeight = max(maxHeight, size[0]);\n            }\n          });\n          if (maxHeight) {\n            heightResizes.push([rowIndex, maxHeight]);\n          }\n        });\n        vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n        heightResized = true;\n      }\n      if (resizedCols.size) {\n        const widthResizes: ItemResize[] = [];\n        resizedCols.forEach((colIndex) => {\n          let maxWidth = 0;\n          maybeCachedRowIndexes.forEach((rowIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxWidth = max(maxWidth, size[1]);\n            }\n          });\n          if (maxWidth) {\n            widthResizes.push([colIndex, maxWidth]);\n          }\n        });\n        hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n        widthResized = true;\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _isJustResized(horizontal?: boolean): boolean {\n      const prev = horizontal ? widthResized : heightResized;\n      if (horizontal) {\n        widthResized = false;\n      } else {\n        heightResized = false;\n      }\n      return prev;\n    },\n  };\n};\n\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n"],"names":["min","Math","max","now","Date","exists","exports","v","range","length","cb","Array","from","_","i","once","fn","called","cache","args","getItemSize","index","size","_sizes","_defaultItemSize","computeOffset","isTotal","_length","_measuredOffsetIndex","_offsets","top","computeStartOffset","findIndex","distance","sum","h","findStartIndexWithOffset","offset","prevStartIndex","prevOffset","findEndIndex","resetCache","itemSize","hasNegativeOffsetInRtl","itemCount","isHorizontal","isRtl","initialItemCount","onScrollStateChange","onScrollOffsetChange","_scrollToQueue","viewportSize","scrollOffset","jump","scrollDirection","_prevRange","subscribers","Set","_getRange","prevEndIndex","start","end","_isUnmeasuredItem","_hasUnmeasuredItemsInRange","startIndex","hasUnmeasuredItemsInRange","endIndex","_getItemOffset","_getItemSize","_getScrollOffset","_getViewportSize","_getScrollSize","computeTotalSize","_getJump","_isHorizontal","_isRtl","_getItemIndexForScrollTo","_waitForScrollDestinationItemsMeasured","Promise","resolve","reject","then","_subscribe","add","delete","_update","type","payload","mutated","updated","filter","updatedJump","forEach","push","setItemSize","_getScrollDirection","_setScrollDirection","dir","prev","_updateCacheLength","window","useLayoutEffect","useEffect","subscibe","getSnapShot","_useSyncExternalStore","scrollable","key","isNegative","refKey","store","isJustResized","rootElement","scrollToKey","getActualScrollSize","scrollWidth","scrollHeight","scrollTo","diff","scrollManually","async","getCurrentOffset","getOffset","scrollSize","e","calcTotalJump","reduce","acc","j","_initRoot","root","syncViewportToScrollPosition","resized","onScrollStopped","debounce","ms","id","cancel","clearTimeout","debouncedFn","setTimeout","_cancel","onScroll","onWheel","throttle","time","n","ctrlKey","deltaX","deltaY","addEventListener","passive","removeEventListener","_getActualScrollSize","_scrollTo","_scrollToIndex","count","_fixScrollJump","allDiff","init","ref","useRef","sizeKey","mountedIndexes","WeakMap","getResizeObserver","ResizeObserver","entries","resizes","target","contentRect","get","_observeRoot","ro","observe","disconnect","_observeItem","el","set","unobserve","_isJustResized","vStore","hStore","heightResized","widthResized","heightKey","widthKey","maybeCachedRowIndexes","maybeCachedColIndexes","sizeCache","Map","getKey","rowIndex","colIndex","resizedRows","resizedCols","cell","prevSize","rowResized","colResized","heightResizes","maxHeight","widthResizes","maxWidth","horizontal"],"mappings":"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"}