import{a as C}from"./jsx-runtime-sgeEVxPu.js";import{r as s}from"./index-yp3VsGQP.js";import{a as X,A as F,b as W,u as E,r as n,U as Z,c as Q,k as $,l as ee,d as te,e as oe,m as ne,n as se,S as re,v as le,V as ae,f as ie,g as ce,o as ue,j as de}from"./useRerender-TobgTKPK.js";import{u as me,a as L,L as fe}from"./useChildren-IssrycUj.js";import{r as pe}from"./index-8dy-jdxy.js";const R=s.forwardRef(({children:f,count:T,overscan:p=4,initialItemSize:h,shift:x,horizontal:k,reverse:O,cache:q,ssrCount:S,components:{Root:A=ae,Item:N="div"}=ie,onScroll:D,onScrollStop:H,onRangeChange:_,...c},P)=>{const[U,a]=me(f,T),b=L(D),g=L(H),y=s.useRef(!!S),[e,v,r,l]=X(()=>{const t=!!k,o=ce(a,h,S,q,!h);return[o,ue(o,t),de(o,t),t]});a!==e._getItemsLength()&&e._update(F,[a,x]);const I=W(e),[u,d]=e._getRange(),m=e._getScrollDirection(),j=e._getJumpCount(),V=e._getScrollSize(),z=s.useRef(null);E(()=>{y[n]=!1;const t=z[n],o=e._subscribe(Z+Q,M=>{M?pe.flushSync(I):I()}),i=e._subscribe($,()=>{b[n]&&b[n](e._getScrollOffset())}),B=e._subscribe(ee,()=>{g[n]&&g[n]()}),G=v._observeRoot(t),K=r._observe(t);return()=>{o(),i(),B(),G(),K()}},[]),E(()=>{const t=e._flushJump();t&&r._fixScrollJump(t)},[j]),s.useEffect(()=>{_&&_(u,d)},[u,d]),s.useImperativeHandle(P,()=>({get cache(){return e._getCache()},get scrollOffset(){return e._getScrollOffset()},get scrollSize(){return e._getScrollSize()},get viewportSize(){return e._getViewportSize()},scrollToIndex:r._scrollToIndex,scrollTo:r._scrollTo,scrollBy:r._scrollBy}),[]);const J=te(u,p,m),Y=oe(d,p,m,a),w=[];for(let t=J;t<=Y;t++){const o=U(t);let i=e._getItemOffset(t);O&&(i+=ne(0,e._getViewportSize()-e._getTotalSize())),w.push(C(fe,{_resizer:v._observeItem,_index:t,_offset:i,_hide:e._isUnmeasuredItem(t),_element:N,_children:o,_isHorizontal:l,_isSSR:y[n]},se(o,t)))}return C(A,{ref:z,width:l?V:void 0,height:l?void 0:V,scrolling:m!==re,attrs:s.useMemo(()=>({...c,style:{display:l?"inline-block":"block",[l?"overflowX":"overflowY"]:"auto",overflowAnchor:"none",contain:"strict",width:"100%",height:"100%",...c.style}}),le(c)),children:w})});try{R.displayName="VList",R.__docgenInfo={description:"Virtualized list component. See {@link VListProps} and {@link VListHandle}.",displayName:"VList",props:{children:{defaultValue:null,description:`Elements rendered by this component.

You can also pass a function and set {@link VListProps.count} to create elements lazily.`,name:"children",required:!0,type:{name:"ReactNode | ((index: number) => ReactElement<any, string | JSXElementConstructor<any>>)"}},count:{defaultValue:null,description:"If you set a function to {@link VListProps.children}, you have to set total number of items to this prop.",name:"count",required:!1,type:{name:"number"}},overscan:{defaultValue:{value:"4"},description:`Number of items to render above/below the visible bounds of the list. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.
@defaultValue 4`,name:"overscan",required:!1,type:{name:"number"}},initialItemSize:{defaultValue:null,description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"initialItemSize",required:!1,type:{name:"number"}},shift:{defaultValue:null,description:"While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.",name:"shift",required:!1,type:{name:"boolean"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean"}},reverse:{defaultValue:null,description:"If true, items are aligned to the end of the list when total size of items are smaller than viewport size. It's useful for chat like app.",name:"reverse",required:!1,type:{name:"boolean"}},cache:{defaultValue:null,description:"You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VListHandle.cache}.",name:"cache",required:!1,type:{name:"CacheSnapshot"}},ssrCount:{defaultValue:null,description:"A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated.",name:"ssrCount",required:!1,type:{name:"number"}},components:{defaultValue:null,description:"Customized components for advanced usage.",name:"components",required:!1,type:{name:"{ Root?: ForwardRefExoticComponent<CustomViewportComponentProps & RefAttributes<any>>; Item?: CustomItemComponentOrElement; }"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop or scrollLeft.`,name:"onScroll",required:!1,type:{name:"(offset: number) => void"}},onScrollStop:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollStop",required:!1,type:{name:"() => void"}},onRangeChange:{defaultValue:null,description:"Callback invoked when visible items range changes.",name:"onRangeChange",required:!1,type:{name:"(startIndex: number, endIndex: number) => void"}}}}}catch{}export{R as V};
