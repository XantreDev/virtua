{"version":3,"file":"useRerender-5pxUOkH4.js","sources":["../../src/core/utils.ts","../../src/core/cache.ts","../../src/core/environment.ts","../../src/core/store.ts","../../src/react/useIsomorphicLayoutEffect.ts","../../src/core/scroller.ts","../../src/react/utils.ts","../../src/react/useStatic.ts","../../src/core/resizer.ts","../../src/react/Viewport.tsx","../../src/react/useRerender.ts"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const abs = Math.abs;\nexport const now = Date.now;\nexport const values = Object.values;\nexport const isArray = Array.isArray;\nexport const timeout = setTimeout;\n\nexport const clamp = (\n  value: number,\n  minValue: number,\n  maxValue: number\n): number => min(maxValue, max(minValue, value));\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const median = (arr: number[]): number => {\n  const s = [...arr].sort((a, b) => a - b);\n  const mid = (arr.length / 2) | 0;\n  return s.length % 2 === 0 ? (s[mid - 1]! + s[mid]!) / 2 : s[mid]!;\n};\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: ReturnType<typeof setTimeout> | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = timeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n\n// wrap for SSR\nexport const computeStyle = (e: HTMLElement) => getComputedStyle(e);\n\nexport const getStyleNumber = (v: string): number => {\n  if (v) {\n    return parseFloat(v);\n  } else {\n    return 0;\n  }\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { clamp, median, min } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _computedOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n): boolean => {\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._computedOffsetIndex = min(index, cache._computedOffsetIndex);\n  return isInitialMeasurement;\n};\n\nexport const computeOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  if (!cache._length) return 0;\n  if (cache._computedOffsetIndex >= index) {\n    return cache._offsets[index]!;\n  }\n\n  let i = cache._computedOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i < index) {\n    top += getItemSize(cache, i);\n    cache._offsets[++i] = top;\n  }\n  // mark as measured\n  cache._computedOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  if (!cache._length) return 0;\n  return (\n    computeOffset(cache, cache._length - 1) +\n    getItemSize(cache, cache._length - 1)\n  );\n};\n\nexport const findIndex = (\n  cache: Writeable<Cache>,\n  offset: number,\n  i: number\n): number => {\n  let sum = computeOffset(cache, i);\n  while (i >= 0 && i < cache._length) {\n    if (sum <= offset) {\n      const next = getItemSize(cache, i);\n      if (sum + next > offset) {\n        break;\n      } else {\n        sum += next;\n        i++;\n      }\n    } else {\n      sum -= getItemSize(cache, --i);\n    }\n  }\n  return clamp(i, 0, cache._length - 1);\n};\n\nexport const computeRange = (\n  cache: Writeable<Cache>,\n  scrollOffset: number,\n  prevStartIndex: number,\n  viewportSize: number\n): [number, number] => {\n  const start = findIndex(\n    cache,\n    scrollOffset,\n    // Clamp because prevStartIndex may exceed the limit when children decreased a lot after scrolling\n    min(prevStartIndex, cache._length - 1)\n  );\n  return [start, findIndex(cache, scrollOffset + viewportSize, start)];\n};\n\nexport const estimateDefaultItemSize = (cache: Writeable<Cache>) => {\n  const measuredSizes = cache._sizes.filter((s) => s !== UNCACHED);\n  // This function will be called after measurement so measured size array must be longer than 0\n  const startItemSize = measuredSizes[0]!;\n\n  cache._defaultItemSize = measuredSizes.every((s) => s === startItemSize)\n    ? // Maybe a fixed size array\n      startItemSize\n    : // Maybe a variable size array\n      median(measuredSizes);\n};\n\nconst appendCache = (\n  cache: Writeable<Cache>,\n  length: number,\n  prepend?: boolean\n) => {\n  const key = prepend ? \"unshift\" : \"push\";\n  for (let i = cache._length; i < length; i++) {\n    cache._sizes[key](UNCACHED);\n    // first offset must be 0\n    cache._offsets.push(i === 0 ? 0 : UNCACHED);\n  }\n  cache._length = length;\n};\n\nexport const initCache = (length: number, itemSize: number): Cache => {\n  const cache: Cache = {\n    _defaultItemSize: itemSize,\n    _length: 0,\n    _computedOffsetIndex: 0,\n    _sizes: [],\n    _offsets: [],\n  };\n  appendCache(cache as Writeable<Cache>, length);\n  return cache;\n};\n\nexport const updateCacheLength = (\n  cache: Writeable<Cache>,\n  length: number,\n  isShift?: boolean\n): [number, boolean] => {\n  const diff = length - cache._length;\n\n  const isRemove = diff < 0;\n  let shift: number;\n  if (isRemove) {\n    // Removed\n    shift = (\n      isShift ? cache._sizes.splice(0, -diff) : cache._sizes.splice(diff)\n    ).reduce(\n      (acc, removed) =>\n        acc + (removed === UNCACHED ? cache._defaultItemSize : removed),\n      0\n    );\n    cache._offsets.splice(diff);\n  } else {\n    // Added\n    shift = cache._defaultItemSize * diff;\n    appendCache(cache, cache._length + diff, isShift);\n  }\n\n  cache._computedOffsetIndex = isShift\n    ? // Discard cache for now\n      0\n    : // measuredOffsetIndex shouldn't be less than 0 because it makes scrollSize NaN and cause infinite rerender.\n      // https://github.com/inokawa/virtua/pull/160\n      clamp(length - 1, 0, cache._computedOffsetIndex);\n  cache._length = length;\n  return [shift, isRemove];\n};\n","import { computeStyle, once } from \"./utils\";\n\nexport const isBrowser = typeof window !== \"undefined\";\n\nconst getDocumentRoot = () => document.documentElement;\n\n// The scroll position may be negative value in rtl direction.\n//\n// left  right result\n// -100  0     true    spec compliant\n// 0     100   false   probably Chrome earlier than v85\n// https://github.com/othree/jquery.rtl-scroll-type\nexport const hasNegativeOffsetInRTL = /*#__PURE__*/ once(\n  (scrollable: HTMLElement): boolean => {\n    const key = \"scrollLeft\";\n    const prev = scrollable[key];\n    scrollable[key] = 1;\n    // scrollLeft can be positive under some specific situations even if negative mode, so we use `<` for now.\n    const isNegative = scrollable[key] < 1;\n    scrollable[key] = prev;\n    return isNegative;\n  }\n);\n\nexport const isRTLDocument = /*#__PURE__*/ once((): boolean => {\n  // TODO support SSR in rtl\n  return isBrowser\n    ? computeStyle(getDocumentRoot()).direction === \"rtl\"\n    : false;\n});\n\n// Currently, all browsers on iOS/iPadOS are WebKit, including WebView.\nexport const isIOSWebKit = /*#__PURE__*/ once((): boolean => {\n  return /iP(hone|od|ad)/.test(navigator.userAgent);\n});\n\nexport const isSmoothScrollSupported = /*#__PURE__*/ once((): boolean => {\n  return \"scrollBehavior\" in getDocumentRoot().style;\n});\n","import {\n  initCache,\n  getItemSize,\n  computeTotalSize,\n  computeOffset as computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  estimateDefaultItemSize,\n  updateCacheLength,\n  computeRange,\n} from \"./cache\";\nimport { isIOSWebKit } from \"./environment\";\nimport type { CacheSnapshot, Writeable } from \"./types\";\nimport { abs, clamp, max, min } from \"./utils\";\n\nexport type ScrollJump = number;\ntype ViewportResize = [size: number, paddingStart: number, paddingEnd: number];\nexport type ItemResize = Readonly<[index: number, size: number]>;\ntype ItemsRange = Readonly<[startIndex: number, endIndex: number]>;\n\nconst calculateJump = (\n  cache: Cache,\n  items: readonly ItemResize[],\n  keepEnd?: boolean\n): number => {\n  return items.reduce((acc, [index, size]) => {\n    const diff = size - getItemSize(cache, index);\n    if (!keepEnd || diff > 0) {\n      acc += diff;\n    }\n    return acc;\n  }, 0);\n};\n\n// Scroll offset and sizes can have sub-pixel value if window.devicePixelRatio has decimal value\nconst SUBPIXEL_THRESHOLD = 1.5; // 0.5 * 3\n\nexport const SCROLL_IDLE = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\nexport type ScrollDirection =\n  | typeof SCROLL_IDLE\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_VIEWPORT_RESIZE = 2;\nexport const ACTION_ITEMS_LENGTH_CHANGE = 3;\nexport const ACTION_SCROLL = 4;\nexport const ACTION_SCROLL_END = 5;\nexport const ACTION_MANUAL_SCROLL = 6;\nexport const ACTION_BEFORE_MANUAL_SMOOTH_SCROLL = 7;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_VIEWPORT_RESIZE, size: ViewportResize]\n  | [\n      type: typeof ACTION_ITEMS_LENGTH_CHANGE,\n      arg: [length: number, isShift?: boolean | undefined]\n    ]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_SCROLL_END, dummy?: void]\n  | [type: typeof ACTION_MANUAL_SCROLL, dummy?: void]\n  | [type: typeof ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, offset: number];\n\ntype Subscriber = (sync?: boolean) => void;\n\nexport const UPDATE_SCROLL_STATE = 0b0001;\nexport const UPDATE_SIZE_STATE = 0b0010;\nexport const UPDATE_SCROLL_WITH_EVENT = 0b0100;\n\nexport type VirtualStore = {\n  _getCache(): CacheSnapshot;\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInSmoothScrollRange(): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getItemsLength(): number;\n  _getScrollOffset(): number;\n  _getScrollOffsetMax(): number;\n  _getScrollDirection(): ScrollDirection;\n  _getViewportSize(): number;\n  _getViewportPaddingStart(): number;\n  _getTotalSize(): number;\n  _getScrollSize(): number;\n  _getJumpCount(): number;\n  _flushJump(): ScrollJump;\n  _subscribe(target: number, cb: Subscriber): () => void;\n  _update(...action: Actions): void;\n};\n\nexport const createVirtualStore = (\n  elementsCount: number,\n  itemSize: number = 40,\n  initialItemCount: number = 0,\n  cache: Cache = initCache(elementsCount, itemSize),\n  isReverse?: boolean,\n  shouldAutoEstimateItemSize?: boolean\n): VirtualStore => {\n  let viewportSize = itemSize * max(initialItemCount - 1, 0);\n  let paddingStart = 0;\n  let paddingEnd = 0;\n  let scrollOffset = 0;\n  let jumpCount = 0;\n  let jump: ScrollJump = 0;\n  let pendingJump: ScrollJump = 0;\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\n  let _isManualScrolling = false;\n  let _smoothScrollRange: ItemsRange | null = null;\n  let _maybeJumped = false;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n\n  const subscribers = new Set<[number, Subscriber]>();\n  const getScrollSize = (): number =>\n    computeTotalSize(cache as Writeable<Cache>);\n  const getScrollOffsetMax = () =>\n    getScrollSize() - viewportSize + paddingStart + paddingEnd;\n\n  const applyJump = (j: ScrollJump) => {\n    // In iOS WebKit browsers, updating scroll position will stop scrolling so it have to be deferred during scrolling.\n    if (isIOSWebKit() && _scrollDirection !== SCROLL_IDLE) {\n      pendingJump += j;\n    } else {\n      jump += j;\n      jumpCount++;\n    }\n  };\n  const updateScrollDirection = (dir: ScrollDirection): boolean => {\n    const prev = _scrollDirection;\n    _scrollDirection = dir;\n    // Return true if scrolling is just started or stopped\n    return _scrollDirection !== prev;\n  };\n\n  return {\n    _getCache() {\n      return JSON.parse(JSON.stringify(cache)) as unknown as CacheSnapshot;\n    },\n    _getRange() {\n      if (_smoothScrollRange) {\n        return [\n          min(_prevRange[0], _smoothScrollRange[0]),\n          max(_prevRange[1], _smoothScrollRange[1]),\n        ];\n      }\n      return (_prevRange = computeRange(\n        cache as Writeable<Cache>,\n        scrollOffset + pendingJump + jump,\n        _prevRange[0],\n        viewportSize\n      ));\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInSmoothScrollRange() {\n      if (!_smoothScrollRange) return false;\n      return cache._sizes\n        .slice(\n          max(0, _smoothScrollRange[0] - 1),\n          min(cache._length - 1, _smoothScrollRange[1] + 1) + 1\n        )\n        .includes(UNCACHED);\n    },\n    _getItemOffset(index) {\n      const offset =\n        computeStartOffset(cache as Writeable<Cache>, index) - pendingJump;\n      if (isReverse) {\n        return offset + max(0, viewportSize - getScrollSize());\n      }\n      return offset;\n    },\n    _getItemSize(index) {\n      return getItemSize(cache, index);\n    },\n    _getItemsLength() {\n      return cache._length;\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getScrollOffsetMax: getScrollOffsetMax,\n    _getScrollDirection() {\n      return _scrollDirection;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getViewportPaddingStart() {\n      return paddingStart;\n    },\n    _getTotalSize() {\n      return max(getScrollSize(), viewportSize - paddingStart - paddingEnd);\n    },\n    _getScrollSize: getScrollSize,\n    _getJumpCount() {\n      return jumpCount;\n    },\n    _flushJump() {\n      const prevJump = jump;\n      jump = 0;\n      return prevJump;\n    },\n    _subscribe(target, cb) {\n      const sub: [number, Subscriber] = [target, cb];\n      subscribers.add(sub);\n      return () => {\n        subscribers.delete(sub);\n      };\n    },\n    _update(type, payload): void {\n      let shouldFlushPendingJump: boolean | undefined;\n      let shouldSync: boolean | undefined;\n      let mutated = 0;\n\n      switch (type) {\n        case ACTION_ITEM_RESIZE: {\n          const updated = payload.filter(\n            ([index, size]) => cache._sizes[index] !== size\n          );\n          // Skip if all items are cached and not updated\n          if (!updated.length) {\n            break;\n          }\n\n          // Calculate jump\n          // Should maintain visible position to minimize junks in appearance\n          let diff = 0;\n\n          if (scrollOffset === 0) {\n            // Do nothing to stick to the start\n          } else if (scrollOffset > getScrollOffsetMax() - SUBPIXEL_THRESHOLD) {\n            // Keep end to stick to the end\n            diff = calculateJump(cache, updated, true);\n          } else {\n            const [startIndex] = _prevRange;\n            // Keep start at mid\n            diff = calculateJump(\n              cache,\n              updated.filter(([index]) => index < startIndex)\n            );\n          }\n\n          if (diff) {\n            applyJump(diff);\n          }\n\n          // Update item sizes\n          let isNewItemMeasured = false;\n          updated.forEach(([index, size]) => {\n            if (setItemSize(cache as Writeable<Cache>, index, size)) {\n              isNewItemMeasured = true;\n            }\n          });\n\n          // Estimate initial item size from measured sizes\n          if (\n            shouldAutoEstimateItemSize &&\n            isNewItemMeasured &&\n            // TODO support reverse scroll also\n            !scrollOffset\n          ) {\n            estimateDefaultItemSize(cache as Writeable<Cache>);\n          }\n          mutated = UPDATE_SIZE_STATE;\n          _maybeJumped = shouldSync = true;\n          break;\n        }\n        case ACTION_VIEWPORT_RESIZE: {\n          const total = payload[0] + payload[1] + payload[2];\n          if (viewportSize !== total) {\n            viewportSize = total;\n            paddingStart = payload[1];\n            paddingEnd = payload[2];\n            mutated = UPDATE_SIZE_STATE;\n          }\n          break;\n        }\n        case ACTION_ITEMS_LENGTH_CHANGE: {\n          if (payload[1]) {\n            // Calc distance before updating cache\n            const distanceToEnd = getScrollOffsetMax() - scrollOffset;\n\n            const [shift, isRemove] = updateCacheLength(\n              cache as Writeable<Cache>,\n              payload[0],\n              true\n            );\n            applyJump(isRemove ? -min(shift, distanceToEnd) : shift);\n\n            mutated = UPDATE_SCROLL_STATE;\n          } else {\n            updateCacheLength(cache as Writeable<Cache>, payload[0]);\n          }\n          break;\n        }\n        case ACTION_SCROLL: {\n          // Skip if offset is not changed\n          if (payload === scrollOffset) {\n            break;\n          }\n\n          const delta = payload - scrollOffset;\n          // Scrolling after resizing will be caused by jump compensation\n          const isJustJumped = _maybeJumped;\n          _maybeJumped = false;\n\n          // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n          // Scroll events are dispatched enough so it's ok to skip some of them.\n          if (\n            (_scrollDirection === SCROLL_IDLE || !isJustJumped) &&\n            // Ignore until manual scrolling\n            !_isManualScrolling\n          ) {\n            updateScrollDirection(delta < 0 ? SCROLL_UP : SCROLL_DOWN);\n          }\n\n          // TODO This will cause glitch in reverse infinite scrolling. Disable this until better solution is found.\n          // if (\n          //   pendingJump &&\n          //   ((_scrollDirection === SCROLL_UP &&\n          //     payload - max(pendingJump, 0) <= 0) ||\n          //     (_scrollDirection === SCROLL_DOWN &&\n          //       payload - min(pendingJump, 0) >= getScrollOffsetMax()))\n          // ) {\n          //   // Flush if almost reached to start or end\n          //   shouldFlushPendingJump = true;\n          // }\n\n          // Update synchronously if scrolled a lot\n          shouldSync = abs(delta) > viewportSize;\n\n          // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\n          scrollOffset = clamp(payload, 0, getScrollOffsetMax());\n\n          mutated = UPDATE_SCROLL_STATE + UPDATE_SCROLL_WITH_EVENT;\n          break;\n        }\n        case ACTION_SCROLL_END: {\n          if (updateScrollDirection(SCROLL_IDLE)) {\n            shouldFlushPendingJump = true;\n            mutated = UPDATE_SCROLL_STATE;\n          }\n          _isManualScrolling = false;\n          _smoothScrollRange = null;\n          break;\n        }\n        case ACTION_MANUAL_SCROLL: {\n          _isManualScrolling = true;\n          break;\n        }\n        case ACTION_BEFORE_MANUAL_SMOOTH_SCROLL: {\n          _smoothScrollRange = computeRange(\n            cache as Writeable<Cache>,\n            payload,\n            _prevRange[0],\n            viewportSize\n          );\n          mutated = UPDATE_SCROLL_STATE;\n          break;\n        }\n      }\n\n      if (mutated) {\n        if (shouldFlushPendingJump && pendingJump) {\n          _maybeJumped = true;\n          jump += pendingJump;\n          pendingJump = 0;\n          jumpCount++;\n        }\n\n        subscribers.forEach(([target, cb]) => {\n          // Early return to skip React's computation\n          if (!(mutated & target)) {\n            return;\n          }\n          // https://github.com/facebook/react/issues/25191\n          // https://github.com/facebook/react/blob/a5fc797db14c6e05d4d5c4dbb22a0dd70d41f5d5/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1443-L1447\n          cb(shouldSync);\n        });\n      }\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\nimport { isBrowser } from \"../core/environment\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect = isBrowser\n  ? useLayoutEffect\n  : useEffect;\n","import {\n  hasNegativeOffsetInRTL,\n  isIOSWebKit,\n  isRTLDocument,\n  isSmoothScrollSupported,\n} from \"./environment\";\nimport {\n  ACTION_SCROLL,\n  ScrollJump,\n  VirtualStore,\n  ACTION_SCROLL_END,\n  UPDATE_SIZE_STATE,\n  ACTION_MANUAL_SCROLL,\n  SCROLL_IDLE,\n  ACTION_BEFORE_MANUAL_SMOOTH_SCROLL,\n} from \"./store\";\nimport { ScrollToIndexOpts } from \"./types\";\nimport { debounce, throttle, timeout, clamp } from \"./utils\";\n\n// Infer scroll state also from wheel events\n// Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\nconst createOnWheel = (\n  store: VirtualStore,\n  isHorizontal: boolean,\n  onScrollStopped: () => void\n) => {\n  return throttle((e: WheelEvent) => {\n    if (store._getScrollDirection() === SCROLL_IDLE) {\n      // Scroll start should be detected with scroll event\n      return;\n    }\n    if (e.ctrlKey) {\n      // Probably a pinch-to-zoom gesture\n      return;\n    }\n    // Get delta before checking deltaMode for firefox behavior\n    // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n    if (isHorizontal ? e.deltaX : e.deltaY) {\n      const offset = store._getScrollOffset();\n      if (offset > 0 && offset < store._getScrollOffsetMax()) {\n        onScrollStopped();\n      }\n    }\n  }, 50);\n};\n\nconst normalizeRTLOffset = (\n  rootElement: HTMLElement,\n  store: VirtualStore,\n  offset: number,\n  diff?: boolean\n): number => {\n  if (hasNegativeOffsetInRTL(rootElement)) {\n    return -offset;\n  } else {\n    return diff ? -offset : store._getScrollOffsetMax() - offset;\n  }\n};\n\nexport type Scroller = {\n  _observe: (rootElement: HTMLElement) => () => void;\n  _scrollTo: (offset: number) => void;\n  _scrollBy: (offset: number) => void;\n  _scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n  _fixScrollJump: (jump: ScrollJump) => void;\n};\n\nexport const createScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): Scroller => {\n  let rootElement: HTMLElement | undefined;\n  let cancelScroll: (() => void) | undefined;\n  let stillMomentumScrolling = false;\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n  const overflowKey = isHorizontal ? \"overflowX\" : \"overflowY\";\n\n  const normalizeOffset = (offset: number, diff?: boolean): number => {\n    if (isHorizontal && isRTLDocument()) {\n      return normalizeRTLOffset(rootElement!, store, offset, diff);\n    }\n    return offset;\n  };\n\n  const scrollManually = async (getOffset: () => number, smooth?: boolean) => {\n    if (!rootElement) return;\n\n    if (cancelScroll) {\n      // Cancel waiting scrollTo\n      cancelScroll();\n    }\n\n    const getTargetOffset = (): number => {\n      // Adjust if the offset is over the end, to get correct startIndex.\n      return clamp(getOffset(), 0, store._getScrollOffsetMax());\n    };\n\n    const waitForMeasurement = (): [Promise<void>, () => void] => {\n      // Wait for the scroll destination items to be measured.\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      // For example, ResizeObserver may not fire when window is not visible.\n      let queue: (() => void) | undefined;\n      return [\n        new Promise<void>((resolve, reject) => {\n          queue = resolve;\n          // Reject when items around scroll destination completely measured\n          timeout((cancelScroll = reject), 150);\n        }),\n        store._subscribe(UPDATE_SIZE_STATE, () => {\n          queue && queue();\n        }),\n      ];\n    };\n\n    if (smooth && isSmoothScrollSupported()) {\n      while (true) {\n        store._update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\n\n        if (!store._hasUnmeasuredItemsInSmoothScrollRange()) {\n          break;\n        }\n\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          await promise;\n        } catch (e) {\n          // canceled\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n\n      rootElement.scrollTo({\n        [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(getTargetOffset()),\n        behavior: \"smooth\",\n      });\n    } else {\n      while (true) {\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          rootElement[scrollToKey] = normalizeOffset(getTargetOffset());\n          store._update(ACTION_MANUAL_SCROLL);\n\n          await promise;\n        } catch (e) {\n          // canceled or finished\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n    }\n  };\n\n  return {\n    _observe(root) {\n      rootElement = root;\n\n      let touching = false;\n      let justTouchEnded = false;\n\n      const onScrollStopped = debounce(() => {\n        if (touching) {\n          // Wait while touching\n          onScrollStopped();\n          return;\n        }\n\n        justTouchEnded = false;\n\n        store._update(ACTION_SCROLL_END);\n      }, 150);\n\n      const onScroll = () => {\n        if (justTouchEnded) {\n          stillMomentumScrolling = true;\n        }\n\n        store._update(ACTION_SCROLL, normalizeOffset(root[scrollToKey]));\n        onScrollStopped();\n      };\n\n      const onWheel = createOnWheel(store, isHorizontal, onScrollStopped);\n\n      const onTouchStart = () => {\n        touching = true;\n        justTouchEnded = stillMomentumScrolling = false;\n      };\n      const onTouchEnd = () => {\n        touching = false;\n        if (isIOSWebKit()) {\n          justTouchEnded = true;\n        }\n      };\n\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n      root.addEventListener(\"touchstart\", onTouchStart, { passive: true });\n      root.addEventListener(\"touchend\", onTouchEnd, { passive: true });\n\n      return () => {\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        root.removeEventListener(\"touchstart\", onTouchStart);\n        root.removeEventListener(\"touchend\", onTouchEnd);\n        onScrollStopped._cancel();\n      };\n    },\n    _scrollTo(offset) {\n      scrollManually(() => offset);\n    },\n    _scrollBy(offset) {\n      offset += store._getScrollOffset();\n      scrollManually(() => offset);\n    },\n    _scrollToIndex(index, { align, smooth } = {}) {\n      index = clamp(index, 0, store._getItemsLength() - 1);\n\n      if (align === \"nearest\") {\n        const itemOffset = store._getItemOffset(index);\n        const scrollOffset = store._getScrollOffset();\n\n        if (itemOffset < scrollOffset) {\n          align = \"start\";\n        } else if (\n          itemOffset + store._getItemSize(index) >\n          scrollOffset + store._getViewportSize()\n        ) {\n          align = \"end\";\n        } else {\n          // already completely visible\n          return;\n        }\n      }\n\n      scrollManually(() => {\n        if (align === \"end\") {\n          return (\n            store._getViewportPaddingStart() +\n            store._getItemOffset(index) +\n            store._getItemSize(index) -\n            store._getViewportSize()\n          );\n        } else if (align === \"center\") {\n          return (\n            store._getViewportPaddingStart() +\n            store._getItemOffset(index) +\n            (store._getItemSize(index) - store._getViewportSize()) / 2\n          );\n        } else {\n          return store._getViewportPaddingStart() + store._getItemOffset(index);\n        }\n      }, smooth);\n    },\n    _fixScrollJump: (jump) => {\n      if (!rootElement) return;\n\n      // If we update scroll position while touching on iOS, the position will be reverted.\n      // However iOS WebKit fires touch events only once at the beginning of momentum scrolling.\n      // That means we have no reliable way to confirm still touched or not if user touches more than once during momentum scrolling...\n      // This is a hack for the suspectable situations, inspired by https://github.com/prud/ios-overflow-scroll-to-top\n      if (stillMomentumScrolling) {\n        stillMomentumScrolling = false;\n\n        const style = rootElement.style;\n        const prev = style[overflowKey];\n        style[overflowKey] = \"hidden\";\n        timeout(() => {\n          style[overflowKey] = prev;\n        });\n      }\n\n      rootElement[scrollToKey] += normalizeOffset(jump, true);\n    },\n  };\n};\n\nexport type WindowScroller = {\n  _observe: (rootElement: HTMLElement) => () => void;\n  _fixScrollJump: (jump: ScrollJump) => void;\n};\n\nexport const createWindowScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowScroller => {\n  let rootElement: HTMLElement | undefined;\n  const scrollToKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n  const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n\n  const normalizeOffset = (offset: number, diff?: boolean): number => {\n    if (isHorizontal && isRTLDocument()) {\n      return normalizeRTLOffset(rootElement!, store, offset, diff);\n    }\n    return offset;\n  };\n\n  return {\n    _observe(root) {\n      rootElement = root;\n\n      // TODO calc offset only when it changes (maybe impossible)\n      const getOffsetToWindow = (node: HTMLElement, offset: number): number => {\n        const nodeOffset =\n          offset +\n          (isHorizontal && isRTLDocument()\n            ? window.innerWidth - node[offsetKey] - node.offsetWidth\n            : node[offsetKey]);\n\n        const parent = node.offsetParent;\n        if (node === document.body || !parent) {\n          return nodeOffset;\n        }\n\n        return getOffsetToWindow(parent as HTMLElement, nodeOffset);\n      };\n\n      const onScrollStopped = debounce(() => {\n        store._update(ACTION_SCROLL_END);\n      }, 150);\n\n      const onScroll = () => {\n        store._update(\n          ACTION_SCROLL,\n          normalizeOffset(window[scrollToKey]) - getOffsetToWindow(root, 0)\n        );\n        onScrollStopped();\n      };\n\n      const onWheel = createOnWheel(store, isHorizontal, onScrollStopped);\n\n      window.addEventListener(\"scroll\", onScroll);\n      window.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        window.removeEventListener(\"scroll\", onScroll);\n        window.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _fixScrollJump: (jump) => {\n      // TODO support case two window scrollers exist in the same view\n      window.scrollBy(\n        isHorizontal ? normalizeOffset(jump, true) : 0,\n        isHorizontal ? 0 : jump\n      );\n    },\n  };\n};\n","import { ReactElement, ReactFragment, ReactNode } from \"react\";\nimport { exists, max, min, isArray } from \"../core/utils\";\nimport { SCROLL_DOWN, SCROLL_UP, ScrollDirection } from \"../core/store\";\n\nexport const refKey = \"current\";\n\nexport const emptyComponents = {};\n\nexport type ItemElement = ReactElement | ReactFragment | string | number;\n\nconst forEach = (children: ReactNode, elements: ItemElement[]) => {\n  if (isArray(children)) {\n    for (const c of children) {\n      forEach(c, elements);\n    }\n  } else if (!exists(children) || typeof children === \"boolean\") {\n    // filter out, that is the same as React.Children.toArray\n  } else {\n    elements.push(children);\n  }\n};\n\n// Replace React.Children.forEach with our tiny implementation.\n// In our usage, just flatten children array keeping element instances and their keys, React.Children is redundant and slow.\n//\n// - React.Children.toArray is slow because it clones element instance.\n// - React.Children.map is slow because it clones element instance.\n// - React.Children.forEach is slow because it escapes and modifies keys even if they are unused.\n//\n// And React.Children seems to be in maintenance mode so it's unlikely it would be improved and ported to older versions.\n// https://github.com/reactjs/rfcs/pull/61#issuecomment-584402735\nexport const flattenChildren = (children: ReactNode): ItemElement[] => {\n  const elements: ItemElement[] = [];\n  forEach(children, elements);\n  return elements;\n};\n\nexport type MayHaveKey = { key?: React.Key };\n\nexport const clampStartIndex = (\n  startIndex: number,\n  overscan: number,\n  scrollDirection: ScrollDirection\n): number => {\n  return max(\n    startIndex - (scrollDirection === SCROLL_DOWN ? 1 : max(1, overscan)),\n    0\n  );\n};\n\nexport const clampEndIndex = (\n  endIndex: number,\n  overscan: number,\n  scrollDirection: ScrollDirection,\n  count: number\n): number => {\n  return min(\n    endIndex + (scrollDirection === SCROLL_UP ? 1 : max(1, overscan)),\n    count - 1\n  );\n};\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import {\n  ACTION_ITEM_RESIZE,\n  ACTION_VIEWPORT_RESIZE,\n  ItemResize,\n  VirtualStore,\n} from \"./store\";\nimport { exists, computeStyle, getStyleNumber, max, once } from \"./utils\";\n\nconst rootObserveOpts: ResizeObserverOptions = { box: \"border-box\" };\n\nexport interface ListResizer {\n  _observeRoot(root: HTMLElement): () => void;\n  _observeItem(el: HTMLElement, i: number): () => void;\n}\n\nexport const createResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  let rootElement: HTMLElement | undefined;\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        // Skip zero-sized rects that may be observed under `display: none` style\n        if (!(target as HTMLElement).offsetParent) continue;\n\n        if (target === rootElement) {\n          store._update(ACTION_VIEWPORT_RESIZE, [\n            contentRect[sizeKey],\n            contentRect[isHorizontal ? \"left\" : \"top\"],\n            // contentRect doesn't have paddingRight/paddingBottom so get them from computed style\n            // https://www.w3.org/TR/resize-observer/#css-definitions\n            getStyleNumber(\n              computeStyle(rootElement)[\n                isHorizontal ? \"paddingRight\" : \"paddingBottom\"\n              ]\n            ),\n          ]);\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root, rootObserveOpts);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport const createWindowResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        // Skip zero-sized rects that may be observed under `display: none` style\n        if (!(target as HTMLElement).offsetParent) continue;\n\n        const index = mountedIndexes.get(target);\n        if (exists(index)) {\n          resizes.push([index, contentRect[sizeKey]]);\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot() {\n      const cb = () => {\n        store._update(ACTION_VIEWPORT_RESIZE, [window[windowSizeKey], 0, 0]);\n      };\n      window.addEventListener(\"resize\", cb);\n      cb();\n      return () => {\n        window.removeEventListener(\"resize\", cb);\n        getResizeObserver().disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let rootElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizedRows = new Set<number>();\n      const resizedCols = new Set<number>();\n      for (const { target, contentRect } of entries) {\n        // Skip zero-sized rects that may be observed under `display: none` style\n        if (!(target as HTMLElement).offsetParent) continue;\n\n        if (target === rootElement) {\n          // contentRect doesn't have paddingRight/paddingBottom so get them from computed style\n          // https://www.w3.org/TR/resize-observer/#css-definitions\n          // TODO subtract scroll bar width/height\n          // https://github.com/w3c/csswg-drafts/issues/3536\n          const style = computeStyle(rootElement);\n          vStore._update(ACTION_VIEWPORT_RESIZE, [\n            contentRect[heightKey],\n            contentRect.top,\n            getStyleNumber(style.paddingBottom),\n          ]);\n          hStore._update(ACTION_VIEWPORT_RESIZE, [\n            contentRect[widthKey],\n            contentRect.left,\n            getStyleNumber(style.paddingRight),\n          ]);\n        } else {\n          const cell = mountedIndexes.get(target);\n          if (cell) {\n            const [rowIndex, colIndex] = cell;\n            const key = getKey(rowIndex, colIndex);\n            const prevSize = sizeCache.get(key);\n            const size: CellSize = [\n              contentRect[heightKey],\n              contentRect[widthKey],\n            ];\n            let rowResized: boolean | undefined;\n            let colResized: boolean | undefined;\n            if (!prevSize) {\n              rowResized = colResized = true;\n            } else {\n              if (prevSize[0] !== size[0]) {\n                rowResized = true;\n              }\n              if (prevSize[1] !== size[1]) {\n                colResized = true;\n              }\n            }\n            if (rowResized) {\n              resizedRows.add(rowIndex);\n            }\n            if (colResized) {\n              resizedCols.add(colIndex);\n            }\n            if (rowResized || colResized) {\n              sizeCache.set(key, size);\n            }\n          }\n        }\n      }\n\n      if (resizedRows.size) {\n        const heightResizes: ItemResize[] = [];\n        resizedRows.forEach((rowIndex) => {\n          let maxHeight = 0;\n          maybeCachedColIndexes.forEach((colIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxHeight = max(maxHeight, size[0]);\n            }\n          });\n          if (maxHeight) {\n            heightResizes.push([rowIndex, maxHeight]);\n          }\n        });\n        vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n      }\n      if (resizedCols.size) {\n        const widthResizes: ItemResize[] = [];\n        resizedCols.forEach((colIndex) => {\n          let maxWidth = 0;\n          maybeCachedRowIndexes.forEach((rowIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxWidth = max(maxWidth, size[1]);\n            }\n          });\n          if (maxWidth) {\n            widthResizes.push([colIndex, maxWidth]);\n          }\n        });\n        hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root, rootObserveOpts);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","import {\n  CSSProperties,\n  ReactElement,\n  ReactNode,\n  forwardRef,\n  useMemo,\n} from \"react\";\n\nexport type ViewportComponentAttributes = Pick<\n  React.HTMLAttributes<HTMLElement>,\n  \"className\" | \"style\" | \"id\" | \"role\" | \"tabIndex\" | \"onKeyDown\"\n> &\n  React.AriaAttributes;\n\n/**\n * Props of customized scrollable component.\n */\nexport interface CustomViewportComponentProps {\n  /**\n   * Renderable item elements.\n   */\n  children: ReactNode;\n  /**\n   * Attributes that should be passed to the scrollable element.\n   */\n  attrs: ViewportComponentAttributes;\n  /**\n   * Total height of items. It's undefined if component is not vertically scrollable.\n   */\n  height: number | undefined;\n  /**\n   * Total width of items. It's undefined if component is not horizontally scrollable.\n   */\n  width: number | undefined;\n  /**\n   * Currently component is scrolling or not.\n   */\n  scrolling: boolean;\n}\n\nexport const Viewport = forwardRef<any, CustomViewportComponentProps>(\n  ({ children, attrs, width, height, scrolling }, ref): ReactElement => {\n    return (\n      <div ref={ref} {...attrs}>\n        <div\n          style={useMemo((): CSSProperties => {\n            return {\n              position: \"relative\",\n              visibility: \"hidden\",\n              width: width ?? \"100%\",\n              height: height ?? \"100%\",\n              pointerEvents: scrolling ? \"none\" : \"auto\",\n            };\n          }, [width, height, scrolling])}\n        >\n          {children}\n        </div>\n      </div>\n    );\n  }\n);\n\nexport type CustomViewportComponent = typeof Viewport;\n","import { useReducer } from \"react\";\n\nconst update = () => [];\n\nexport const useRerender = (): (() => void) => {\n  return useReducer(update, undefined, update)[1];\n};\n"],"names":["min","max","abs","now","values","isArray","timeout","clamp","value","minValue","maxValue","exists","v","median","arr","s","a","b","mid","debounce","fn","ms","id","cancel","debouncedFn","throttle","time","args","n","once","called","cache","computeStyle","getStyleNumber","UNCACHED","getItemSize","index","size","setItemSize","isInitialMeasurement","computeOffset","i","top","computeTotalSize","findIndex","offset","sum","next","computeRange","scrollOffset","prevStartIndex","viewportSize","start","estimateDefaultItemSize","measuredSizes","startItemSize","appendCache","length","prepend","key","initCache","itemSize","updateCacheLength","isShift","diff","isRemove","shift","acc","removed","isBrowser","getDocumentRoot","hasNegativeOffsetInRTL","scrollable","prev","isNegative","isRTLDocument","isIOSWebKit","isSmoothScrollSupported","calculateJump","items","keepEnd","SUBPIXEL_THRESHOLD","SCROLL_IDLE","SCROLL_DOWN","SCROLL_UP","ACTION_ITEM_RESIZE","ACTION_VIEWPORT_RESIZE","ACTION_ITEMS_LENGTH_CHANGE","ACTION_SCROLL","ACTION_SCROLL_END","ACTION_MANUAL_SCROLL","ACTION_BEFORE_MANUAL_SMOOTH_SCROLL","UPDATE_SCROLL_STATE","UPDATE_SIZE_STATE","UPDATE_SCROLL_WITH_EVENT","createVirtualStore","elementsCount","initialItemCount","isReverse","shouldAutoEstimateItemSize","paddingStart","paddingEnd","jumpCount","jump","pendingJump","_scrollDirection","_isManualScrolling","_smoothScrollRange","_maybeJumped","_prevRange","subscribers","getScrollSize","getScrollOffsetMax","applyJump","j","updateScrollDirection","dir","computeStartOffset","prevJump","target","cb","sub","type","payload","shouldFlushPendingJump","shouldSync","mutated","updated","startIndex","isNewItemMeasured","total","distanceToEnd","delta","isJustJumped","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","createOnWheel","store","isHorizontal","onScrollStopped","e","normalizeRTLOffset","rootElement","createScroller","cancelScroll","stillMomentumScrolling","scrollToKey","overflowKey","normalizeOffset","scrollManually","getOffset","smooth","getTargetOffset","waitForMeasurement","queue","resolve","reject","promise","unsubscribe","root","touching","justTouchEnded","onScroll","onWheel","onTouchStart","onTouchEnd","align","itemOffset","style","createWindowScroller","offsetKey","getOffsetToWindow","node","nodeOffset","parent","refKey","emptyComponents","forEach","children","elements","c","flattenChildren","clampStartIndex","overscan","scrollDirection","clampEndIndex","endIndex","count","useStatic","init","ref","useRef","rootObserveOpts","createResizer","sizeKey","mountedIndexes","getResizeObserver","entries","resizes","contentRect","ro","el","createWindowResizer","windowSizeKey","createGridResizer","vStore","hStore","heightKey","widthKey","maybeCachedRowIndexes","maybeCachedColIndexes","sizeCache","getKey","rowIndex","colIndex","resizedRows","resizedCols","cell","prevSize","rowResized","colResized","heightResizes","maxHeight","widthResizes","maxWidth","Viewport","forwardRef","attrs","width","height","scrolling","jsx","useMemo","update","useRerender","useReducer"],"mappings":"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"}