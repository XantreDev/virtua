import{j as E}from"./jsx-runtime-c3d7f245.js";import{r as d}from"./index-c6dae603.js";import{r as ce}from"./index-eb008d06.js";const M=Math.min,T=Math.max,B=Date.now,L=e=>e!=null,Q=(e,t)=>Array.from({length:e},(n,r)=>t(r)),ae=(e,t)=>{let n;const r=()=>{L(n)&&clearTimeout(n)},l=()=>{r(),n=setTimeout(()=>{n=null,e()},t)};return l._cancel=r,l},fe=(e,t)=>{let n=B()-t;return(...r)=>{const l=B();n+t<l&&(n=l,e(...r))}},re=e=>{let t,n;return(...r)=>(t||(t=!0,n=e(...r)),n)},x=-1,D=(e,t)=>{const n=e._sizes[t];return n===x?e._defaultItemSize:n},de=(e,t,n)=>{e._sizes[t]=n,e._measuredOffsetIndex=M(t,e._measuredOffsetIndex)},se=(e,t,n)=>{if(!e._length)return 0;if(e._measuredOffsetIndex>=t)return n?e._offsets[t]+D(e,t):e._offsets[t];let r=e._measuredOffsetIndex,l=e._offsets[r];for(;r<=t&&(e._offsets[r]=l,!(r===t&&!n));)l+=D(e,r),r++;return e._measuredOffsetIndex=t,l},me=e=>se(e,e._length-1,!0),X=(e,t)=>se(e,t),oe=(e,t,n)=>{let r=0;if(n>=0)for(;t<e._length-1;){const l=D(e,t++);if((r+=l)>=n){r-l/2>=n&&t--;break}}else for(;t>0;){const l=D(e,--t);if((r-=l)<=n){r+l/2<n&&t++;break}}return M(T(t,0),e._length-1)},G=(e,t,n,r)=>oe(e,n,t-r),$=oe,_e=(e,t,n)=>{for(let r=t;r<=n;r++)if(e._sizes[r]===x)return!0;return!1},ee=(e,t,n)=>({_defaultItemSize:t,_length:e,_measuredOffsetIndex:n?M(n._measuredOffsetIndex,e-1):0,_sizes:Q(e,r=>{const l=n&&n._sizes[r];return L(l)?l:x}),_offsets:Q(e,r=>{if(r===0)return 0;const l=n&&n._offsets[r];return L(l)?l:x})}),C=0,le=1,K=2,J=3,N=1,ie=2,A=3,j=4,pe=(e,t,n,r,l=0,a,I)=>{let _=t*T(l-1,0),z=0,w=[],c=ee(e,t),v=C,b=[0,l],s;const u=new Set;return{_getRange(){const[o,i]=b,p=X(c,o),f=G(c,z,o,p),S=$(c,f,_);return o===f&&i===S?b:b=[f,S]},_isUnmeasuredItem(o){return c._sizes[o]===x},_hasUnmeasuredItemsInRange(o){return _e(c,o,$(c,o,_))},_getItemOffset(o){return X(c,o)},_getScrollOffset(){return z},_getViewportSize(){return _},_getScrollSize(){return me(c)},_getJump(){return w},_isHorizontal(){return n},_isRtl(){return r},_getItemIndexForScrollTo(o){return G(c,o,0,0)},_waitForScrollDestinationItemsMeasured(){return s&&s[1](),new Promise((o,i)=>{s=[()=>{Promise.resolve().then(()=>{o(),s=void 0})},i]})},_subscribe(o){return u.add(o),()=>{u.delete(o)}},_update(o,i){(()=>{switch(o){case N:{const f=i.filter(([g,m])=>c._sizes[g]!==m);if(!f.length)return!1;const S=[];return f.forEach(([g,m])=>{S.push([g,m-D(c,g)]),de(c,g,m)}),w=S,!0}case ie:return _===i?!1:(_=i,!0);case A:case j:{const f=z;return(z=i)!==f}}})()&&(u.forEach(f=>{f(o===N||o===A)}),o===A?I(z):s&&o===N&&s[0]())},_getScrollDirection(){return v},_setScrollDirection(o){const i=v;v=o,v===C?a(!1):i===C&&(v===le||v===K)&&a(!0)},_updateCacheLength(o){c._length!==o&&(c=ee(o,t,c))}}},q=typeof window<"u"?d.useLayoutEffect:d.useEffect,O="current",Y=e=>{const t=d.useRef(e);return q(()=>{t[O]=e},[e]),t},k=(e,t,n)=>{const r=Y(t),[l,a]=d.useState(t);return d.useLayoutEffect(()=>{if(n)return;const I=()=>{a(r[O])};return e._subscribe(_=>{_?ce.flushSync(I):I()})},[n]),l},te=re(e=>{const t="scrollLeft",n=e[t];e[t]=1;const r=e[t]===0;return e[t]=n,r}),Se=e=>{let t=!1,n;const r=e._isHorizontal(),l=e._isRtl(),a=r?"scrollLeft":"scrollTop",I=r?"width":"height",_=new WeakMap,z=re(()=>new ResizeObserver(s=>{const u=[];for(const{target:o,contentRect:i}of s)if(o===n)e._update(ie,i[I]);else{const p=_.get(o);L(p)&&u.push([p,i[I]])}u.length&&(e._update(N,u),t=!0)})),w=()=>n?r?n.scrollWidth:n.scrollHeight:0,c=(s,u)=>{n&&(r&&l&&te(n)&&(s*=-1),u?n[a]+=s:(n[a]=s,e._setScrollDirection(J)))},v=async(s,u)=>{const o=()=>{let i=u();const p=w(),f=e._getViewportSize();return p-(i+f)<=0&&(i=p-f),i};if(e._hasUnmeasuredItemsInRange(s)){do{e._update(j,o());try{await e._waitForScrollDestinationItemsMeasured()}catch{return}}while(e._hasUnmeasuredItemsInRange(s));c(o())}else{const i=o();c(i),e._update(j,i)}},b=s=>s.reduce((u,[,o])=>u+o,0);return{_initRoot(s){n=s;const u=z(),o=()=>{let S=s[a];r&&l&&te(s)&&(S*=-1);const g=e._getScrollOffset();if(g===S)return;const m=e._getScrollDirection();(m===C||!t)&&m!==J&&e._setScrollDirection(g>S?K:le),t=!1,e._update(A,S)},i=ae(()=>{o(),e._setScrollDirection(C)},150),p=()=>{o(),i()},f=fe(S=>{if(e._getScrollDirection()!==C&&!S.ctrlKey&&(r?S.deltaX:S.deltaY)){const g=e._getScrollOffset();g>0&&g<e._getScrollSize()-e._getViewportSize()&&i()}},50);return u.observe(s),s.addEventListener("scroll",p),s.addEventListener("wheel",f,{passive:!0}),()=>{u.disconnect(),s.removeEventListener("scroll",p),s.removeEventListener("wheel",f),i._cancel()}},_initItem(s,u){const o=z();return _.set(s,u),o.observe(s),()=>{_.delete(s),o.unobserve(s)}},_getActualScrollSize:w,_scrollTo(s){s=T(s,0),v(e._getItemIndexForScrollTo(s),()=>s)},_scrollToIndex(s,u){s=T(M(s,u-1),0),v(s,()=>e._getItemOffset(s))},_fixScrollJump:(s,u)=>{const o=e._getScrollDirection();if(o===K){const i=b(s);i&&c(i,!0)}else if(o===J){const i=e._getScrollOffset();if(i!==0){const p=b(s);if(e._getScrollSize()-(i+e._getViewportSize()+p)<=0)p&&c(i+p);else{const f=s.reduce((S,[g,m])=>(g<u&&(S+=m),S),0);f&&c(f,!0)}}}}}},he=e=>{const t=d.useRef();return t[O]||(t[O]=e())},ge=d.memo(({_children:e,_scroller:t,_store:n,_index:r,_element:l,_isOffscreen:a})=>{const I=d.useRef(null),_=k(n,()=>n._getItemOffset(r),a),z=k(n,()=>n._isUnmeasuredItem(r),a);return q(()=>t._initItem(I[O],r),[r]),E(l,{ref:I,style:d.useMemo(()=>{const w=n._isHorizontal(),c=n._isRtl()?"right":"left",v={margin:0,padding:0,position:"absolute",[w?"height":"width"]:"100%",[w?"top":c]:0,[w?c:"top"]:_,visibility:z||a?"hidden":"visible"};return w&&(v.display="flex"),v},[_,z,a]),children:e})}),Ie=e=>!L(e)||typeof e=="boolean",ve=d.forwardRef(({children:e,scrollSize:t,scrolling:n,horizontal:r,attrs:l},a)=>E("div",{ref:a,...l,children:E("div",{style:d.useMemo(()=>({position:"relative",visibility:"hidden",width:r?t:"100%",height:r?"100%":t,pointerEvents:n?"none":"auto"}),[t,n]),children:e})})),ze=({_children:e,_ref:t,_store:n,_element:r,_scrolling:l,_attrs:a})=>{const I=k(n,n._getScrollSize),_=n._isHorizontal();return E(r,{ref:t,scrollSize:I,scrolling:l,horizontal:_,attrs:d.useMemo(()=>({...a,style:{overflow:_?"auto hidden":"hidden auto",contain:"strict",width:"100%",height:"100%",padding:0,margin:0,...a.style}}),[a]),children:e})},ne=d.forwardRef(({children:e,itemSize:t=40,overscan:n=4,initialItemCount:r,horizontal:l,rtl:a,element:I=ve,itemElement:_="div",onScroll:z,onScrollStop:w,onRangeChange:c,...v},b)=>{const s=d.useMemo(()=>{const y=[];return d.Children.forEach(e,h=>{Ie(h)||y.push(h)}),y},[e]),u=s.length,o=Y(z),i=Y(w),[p,f]=d.useState(new Set),[S,g]=d.useState(!1),[m,R]=he(()=>{const y=pe(u,t,!!l,!!a,r,h=>{g(h),h||(f(new Set),i[O]&&i[O]())},h=>{o[O]&&o[O](h)});return[y,Se(y)]});m._updateCacheLength(u);const[W,U]=k(m,m._getRange),H=k(m,m._getJump),Z=d.useRef(null);q(()=>R._initRoot(Z[O]),[]),q(()=>{H.length&&R._fixScrollJump(H,W)},[H]),d.useEffect(()=>{c&&c({start:W,end:U,count:u})},[W,U]),d.useImperativeHandle(b,()=>({get scrollOffset(){return m._getScrollOffset()},get scrollSize(){return R._getActualScrollSize()},get viewportSize(){return m._getViewportSize()},scrollToIndex(y){R._scrollToIndex(y,u)},scrollTo:R._scrollTo,scrollBy(y){R._scrollTo(m._getScrollOffset()+y)}}),[u]);const P=T(W-n,0),F=M(U+n,u-1),ue=d.useMemo(()=>{const y=[];for(let h=P;h<=F;h++)p.add(h);return p.forEach(h=>{const V=s[h];L(V)&&y.push(E(ge,{_scroller:R,_store:m,_index:h,_element:_,_children:V,_isOffscreen:h<P||h>F},(V==null?void 0:V.key)||h))}),y},[s,p,P,F]);return E(ze,{_ref:Z,_store:m,_element:I,_scrolling:S,_children:ue,_attrs:v})});try{ne.displayName="VList",ne.__docgenInfo={description:"Virtualized list component. See {@link VListProps} and {@link VListHandle}.",displayName:"VList",props:{children:{defaultValue:null,description:"Elements rendered by this component.",name:"children",required:!0,type:{name:"ReactNode"}},itemSize:{defaultValue:null,description:`Item size hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.
@defaultValue 40`,name:"itemSize",required:!1,type:{name:"number"}},overscan:{defaultValue:{value:"4"},description:`Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.
@defaultValue 4`,name:"overscan",required:!1,type:{name:"number"}},initialItemCount:{defaultValue:null,description:"If set, the specified amount of items will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.",name:"initialItemCount",required:!1,type:{name:"number"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean"}},rtl:{defaultValue:null,description:"You have to set true if you use this component under `direction: rtl` style.",name:"rtl",required:!1,type:{name:"boolean"}},element:{defaultValue:{value:`forwardRef<any, CustomWindowComponentProps>(
  (
    { children, scrollSize, scrolling, horizontal, attrs },
    ref
  ): ReactElement => {
    return (
      <div ref={ref} {...attrs}>
        <div
          style={useMemo((): CSSProperties => {
            return {
              position: "relative",
              visibility: "hidden",
              width: horizontal ? scrollSize : "100%",
              height: horizontal ? "100%" : scrollSize,
              pointerEvents: scrolling ? "none" : "auto",
            };
          }, [scrollSize, scrolling])}
        >
          {children}
        </div>
      </div>
    );
  }
)`},description:`Customized element type for scrollable element. This element will get {@link CustomWindowComponentProps} as props.
@defaultValue {@link DefaultWindow }`,name:"element",required:!1,type:{name:"ForwardRefExoticComponent<CustomWindowComponentProps & RefAttributes<any>>"}},itemElement:{defaultValue:{value:"div"},description:`Customized element type for item element. This element will get {@link CustomItemComponentProps} as props.
@defaultValue "div"`,name:"itemElement",required:!1,type:{name:"CustomItemComponentOrElement"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop or scrollLeft.`,name:"onScroll",required:!1,type:{name:"(offset: number) => void"}},onScrollStop:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollStop",required:!1,type:{name:"() => void"}},onRangeChange:{defaultValue:null,description:"Callback invoked when visible items range changes.",name:"onRangeChange",required:!1,type:{name:"(payload: { start: number; end: number; count: number; }) => void"}}}}}catch{}export{ne as V};
//# sourceMappingURL=VList-1f03ecb3.js.map
