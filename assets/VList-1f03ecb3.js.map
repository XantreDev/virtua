{"version":3,"file":"VList-1f03ecb3.js","sources":["../../src/core/utils.ts","../../src/core/cache.ts","../../src/core/store.ts","../../src/react/useIsomorphicLayoutEffect.ts","../../src/react/utils.ts","../../src/react/useRefWithUpdate.ts","../../src/react/useStore.ts","../../src/core/scroller.ts","../../src/react/useStatic.ts","../../src/react/VList.tsx"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const now = Date.now;\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const range = <T>(length: number, cb: (i: number) => T): T[] =>\n  Array.from({ length }, (_, i) => cb(i));\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: NodeJS.Timeout | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = setTimeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { exists, max, min, range } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _measuredOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n) => {\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._measuredOffsetIndex = min(index, cache._measuredOffsetIndex);\n};\n\nconst computeOffset = (\n  cache: Writeable<Cache>,\n  index: number,\n  isTotal?: boolean\n): number => {\n  if (!cache._length) return 0;\n  if (cache._measuredOffsetIndex >= index) {\n    if (isTotal) {\n      return cache._offsets[index]! + getItemSize(cache, index);\n    } else {\n      return cache._offsets[index]!;\n    }\n  }\n\n  let i = cache._measuredOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i <= index) {\n    cache._offsets[i] = top;\n    if (i === index && !isTotal) {\n      break;\n    }\n    top += getItemSize(cache, i);\n    i++;\n  }\n  // mark as measured\n  cache._measuredOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  return computeOffset(cache, cache._length - 1, true);\n};\n\nexport const computeStartOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  return computeOffset(cache, index);\n};\n\nconst findIndex = (cache: Cache, i: number, distance: number): number => {\n  let sum = 0;\n  if (distance >= 0) {\n    // search forward\n    while (i < cache._length - 1) {\n      const h = getItemSize(cache, i++);\n      if ((sum += h) >= distance) {\n        if (sum - h / 2 >= distance) {\n          i--;\n        }\n        break;\n      }\n    }\n  } else {\n    // search backward\n    while (i > 0) {\n      const h = getItemSize(cache, --i);\n      if ((sum -= h) <= distance) {\n        if (sum + h / 2 < distance) {\n          i++;\n        }\n        break;\n      }\n    }\n  }\n\n  return min(max(i, 0), cache._length - 1);\n};\n\nexport const findStartIndexWithOffset = (\n  cache: Cache,\n  offset: number,\n  prevStartIndex: number,\n  prevOffset: number\n): number => {\n  return findIndex(cache, prevStartIndex, offset - prevOffset);\n};\n\nexport const findEndIndex = findIndex;\n\nexport const hasUnmeasuredItemsInRange = (\n  cache: Cache,\n  startIndex: number,\n  endIndex: number\n): boolean => {\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (cache._sizes[i] === UNCACHED) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const resetCache = (\n  length: number,\n  itemSize: number,\n  cache?: Cache\n): Cache => {\n  return {\n    _defaultItemSize: itemSize,\n    _length: length,\n    _measuredOffsetIndex: cache\n      ? min(cache._measuredOffsetIndex, length - 1)\n      : 0,\n    _sizes: range(length, (i) => {\n      const size = cache && cache._sizes[i];\n      if (exists(size)) {\n        return size;\n      }\n      return UNCACHED;\n    }),\n    _offsets: range(length, (i) => {\n      if (i === 0) {\n        // first offset must be 0\n        return 0;\n      }\n      const offset = cache && cache._offsets[i];\n      if (exists(offset)) {\n        return offset;\n      }\n      return UNCACHED;\n    }),\n  };\n};\n","import {\n  findStartIndexWithOffset,\n  resetCache,\n  getItemSize,\n  computeTotalSize,\n  findEndIndex,\n  computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  hasUnmeasuredItemsInRange,\n} from \"./cache\";\nimport type { Writeable } from \"./types\";\nimport { max } from \"./utils\";\n\nexport type ScrollJump = Readonly<[index: number, sizeDiff: number][]>;\nexport type ItemResize = [index: number, size: number];\ntype ItemsRange = [startIndex: number, endIndex: number];\n\nexport const SCROLL_STOP = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\nexport const SCROLL_MANUAL = 3;\ntype ScrollDirection =\n  | typeof SCROLL_STOP\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP\n  | typeof SCROLL_MANUAL;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_WINDOW_RESIZE = 2;\nexport const ACTION_SCROLL = 3;\nexport const ACTION_MANUAL_SCROLL = 4;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_WINDOW_RESIZE, size: number]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, offset: number];\n\ntype Subscriber = (sync?: boolean) => void;\n\nexport type VirtualStore = {\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInRange(startIndex: number): boolean;\n  _getItemOffset(index: number): number;\n  _getScrollOffset(): number;\n  _getViewportSize(): number;\n  _getScrollSize(): number;\n  _getJump(): ScrollJump;\n  _isHorizontal(): boolean;\n  _isRtl(): boolean;\n  _getItemIndexForScrollTo(offset: number): number;\n  _waitForScrollDestinationItemsMeasured(): Promise<void>;\n  _subscribe(cb: Subscriber): () => void;\n  _update(...action: Actions): void;\n  _getScrollDirection(): ScrollDirection;\n  _setScrollDirection(direction: ScrollDirection): void;\n  _updateCacheLength(length: number): void;\n};\n\nexport const createVirtualStore = (\n  itemCount: number,\n  itemSize: number,\n  isHorizontal: boolean,\n  isRtl: boolean,\n  initialItemCount: number = 0,\n  onScrollStateChange: (scrolling: boolean) => void,\n  onScrollOffsetChange: (offset: number) => void\n): VirtualStore => {\n  let viewportSize = itemSize * max(initialItemCount - 1, 0);\n  let scrollOffset = 0;\n  let jump: ScrollJump = [];\n  let cache = resetCache(itemCount, itemSize);\n  let scrollDirection: ScrollDirection = SCROLL_STOP;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n  let _scrollToQueue: [() => void, () => void] | undefined;\n\n  const subscribers = new Set<Subscriber>();\n\n  return {\n    _getRange() {\n      const [prevStartIndex, prevEndIndex] = _prevRange;\n      const prevOffset = computeStartOffset(\n        cache as Writeable<Cache>,\n        prevStartIndex\n      );\n      const start = findStartIndexWithOffset(\n        cache,\n        scrollOffset,\n        prevStartIndex,\n        prevOffset\n      );\n      const end = findEndIndex(cache, start, viewportSize);\n      if (prevStartIndex === start && prevEndIndex === end) {\n        return _prevRange;\n      }\n      return (_prevRange = [start, end]);\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInRange(startIndex) {\n      return hasUnmeasuredItemsInRange(\n        cache,\n        startIndex,\n        findEndIndex(cache, startIndex, viewportSize)\n      );\n    },\n    _getItemOffset(index) {\n      return computeStartOffset(cache as Writeable<Cache>, index);\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getScrollSize() {\n      return computeTotalSize(cache as Writeable<Cache>);\n    },\n    _getJump() {\n      return jump;\n    },\n    _isHorizontal() {\n      return isHorizontal;\n    },\n    _isRtl() {\n      return isRtl;\n    },\n    _getItemIndexForScrollTo(offset) {\n      return findStartIndexWithOffset(cache, offset, 0, 0);\n    },\n    _waitForScrollDestinationItemsMeasured() {\n      if (_scrollToQueue) {\n        // Cancel waiting scrollTo\n        _scrollToQueue[1]();\n      }\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      // For example, ResizeObserver may not fire when window is not visible.\n      return new Promise((resolve, reject) => {\n        _scrollToQueue = [\n          () => {\n            // HACK: It should be resolved in the next microtask that is after React's render\n            Promise.resolve().then(() => {\n              resolve();\n              _scrollToQueue = undefined;\n            });\n          },\n          reject,\n        ];\n      });\n    },\n    _subscribe(cb) {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    _update(type, payload) {\n      const mutated = ((): boolean => {\n        switch (type) {\n          case ACTION_ITEM_RESIZE: {\n            const updated = payload.filter(\n              ([index, size]) => cache._sizes[index] !== size\n            );\n            // Skip if all items are cached and not updated\n            if (!updated.length) {\n              return false;\n            }\n\n            const updatedJump: [index: number, sizeDiff: number][] = [];\n            updated.forEach(([index, size]) => {\n              updatedJump.push([index, size - getItemSize(cache, index)]);\n              setItemSize(cache as Writeable<Cache>, index, size);\n            });\n            jump = updatedJump;\n            return true;\n          }\n          case ACTION_WINDOW_RESIZE: {\n            if (viewportSize === payload) {\n              return false;\n            }\n            viewportSize = payload;\n            return true;\n          }\n          case ACTION_SCROLL:\n          case ACTION_MANUAL_SCROLL: {\n            const prevOffset = scrollOffset;\n            return (scrollOffset = payload) !== prevOffset;\n          }\n        }\n      })();\n\n      if (mutated) {\n        subscribers.forEach((cb) => {\n          cb(\n            type === ACTION_ITEM_RESIZE || type === ACTION_SCROLL ? true : false\n          );\n        });\n\n        if (type === ACTION_SCROLL) {\n          onScrollOffsetChange(scrollOffset);\n        } else if (_scrollToQueue && type === ACTION_ITEM_RESIZE) {\n          _scrollToQueue[0]();\n        }\n      }\n    },\n    _getScrollDirection() {\n      return scrollDirection;\n    },\n    _setScrollDirection(dir) {\n      const prev = scrollDirection;\n      scrollDirection = dir;\n      if (scrollDirection === SCROLL_STOP) {\n        onScrollStateChange(false);\n      } else if (\n        prev === SCROLL_STOP &&\n        (scrollDirection === SCROLL_DOWN || scrollDirection === SCROLL_UP)\n      ) {\n        onScrollStateChange(true);\n      }\n    },\n    _updateCacheLength(length) {\n      // It's ok to be updated in render because states should be calculated consistently regardless cache length\n      if (cache._length === length) return;\n      cache = resetCache(length, itemSize, cache);\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","export const refKey = \"current\";\n","import { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { refKey } from \"./utils\";\n\nexport const useRefWithUpdate = <T>(value: T) => {\n  const ref = useRef<T>(value);\n\n  useIsomorphicLayoutEffect(() => {\n    ref[refKey] = value;\n  }, [value]);\n\n  return ref;\n};\n","import { useLayoutEffect, useState } from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { useRefWithUpdate } from \"./useRefWithUpdate\";\nimport { refKey } from \"./utils\";\nimport { VirtualStore } from \"../core/store\";\n\nexport const useStore = <T>(\n  store: VirtualStore,\n  getSnapShot: () => T,\n  disabled?: boolean\n): T => {\n  const getter = useRefWithUpdate(getSnapShot);\n  const [state, setState] = useState(getSnapShot);\n\n  useLayoutEffect(() => {\n    if (disabled) return;\n\n    const update = () => {\n      setState(getter[refKey]);\n    };\n    return store._subscribe((sync) => {\n      if (sync) {\n        flushSync(update);\n      } else {\n        update();\n      }\n    });\n  }, [disabled]);\n\n  return state;\n};\n","import {\n  ACTION_SCROLL,\n  ACTION_MANUAL_SCROLL,\n  ACTION_ITEM_RESIZE,\n  ACTION_WINDOW_RESIZE,\n  ItemResize,\n  ScrollJump,\n  VirtualStore,\n  SCROLL_MANUAL,\n  SCROLL_STOP,\n  SCROLL_UP,\n  SCROLL_DOWN,\n} from \"./store\";\nimport { debounce, throttle, exists, max, min, once } from \"./utils\";\n\n// The scroll position may be negative value in rtl direction.\n// https://github.com/othree/jquery.rtl-scroll-type\nconst hasNegativeOffsetInRtl = once((scrollable: HTMLElement) => {\n  const key = \"scrollLeft\";\n  const prev = scrollable[key];\n  scrollable[key] = 1;\n  const isNegative = scrollable[key] === 0;\n  scrollable[key] = prev;\n  return isNegative;\n});\n\nexport type Scroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _initItem: (itemElement: HTMLElement, index: number) => () => void;\n  _getActualScrollSize: () => number;\n  _scrollTo: (offset: number) => void;\n  _scrollToIndex: (index: number, count: number) => void;\n  _fixScrollJump: (jump: ScrollJump, startIndex: number) => void;\n};\n\nexport const createScroller = (store: VirtualStore): Scroller => {\n  let resized = false;\n  let rootElement: HTMLElement | undefined;\n  const isHorizontal = store._isHorizontal();\n  const isRtl = store._isRtl();\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    return new ResizeObserver((entries) => {\n      // https://www.w3.org/TR/resize-observer/#intro\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          store._update(ACTION_WINDOW_RESIZE, contentRect[sizeKey]);\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n        resized = true;\n      }\n    });\n  });\n  const getActualScrollSize = (): number => {\n    if (!rootElement) return 0;\n    // Use element's scrollHeight/scrollWidth instead of stored scrollSize.\n    // This is because stored size may differ from the actual size, for example when a new item is added and not yet measured.\n    return isHorizontal ? rootElement.scrollWidth : rootElement.scrollHeight;\n  };\n  const scrollTo = (offset: number, diff?: boolean) => {\n    if (!rootElement) return;\n    if (isHorizontal && isRtl) {\n      if (hasNegativeOffsetInRtl(rootElement)) {\n        offset *= -1;\n      }\n    }\n    if (diff) {\n      rootElement[scrollToKey] += offset;\n    } else {\n      rootElement[scrollToKey] = offset;\n      store._setScrollDirection(SCROLL_MANUAL);\n    }\n  };\n  const scrollManually = async (\n    index: number,\n    getCurrentOffset: () => number\n  ) => {\n    const getOffset = (): number => {\n      let offset = getCurrentOffset();\n      const scrollSize = getActualScrollSize();\n      const viewportSize = store._getViewportSize();\n      if (scrollSize - (offset + viewportSize) <= 0) {\n        // Adjust if the offset is over the end, to get correct startIndex.\n        offset = scrollSize - viewportSize;\n      }\n      return offset;\n    };\n\n    if (store._hasUnmeasuredItemsInRange(index)) {\n      do {\n        // In order to scroll to the correct position, mount the items and measure their sizes before scrolling.\n        store._update(ACTION_MANUAL_SCROLL, getOffset());\n        try {\n          // Wait for the scroll destination items to be measured.\n          await store._waitForScrollDestinationItemsMeasured();\n        } catch (e) {\n          // canceled\n          return;\n        }\n      } while (store._hasUnmeasuredItemsInRange(index));\n\n      // Scroll with the updated value\n      scrollTo(getOffset());\n    } else {\n      const offset = getOffset();\n      scrollTo(offset);\n      // Sync viewport to scroll destination\n      store._update(ACTION_MANUAL_SCROLL, offset);\n    }\n  };\n\n  const calcTotalJump = (jump: ScrollJump): number =>\n    jump.reduce((acc, [, j]) => acc + j, 0);\n\n  return {\n    _initRoot(root) {\n      rootElement = root;\n      const ro = getResizeObserver();\n\n      const syncViewportToScrollPosition = () => {\n        let offset = root[scrollToKey];\n        if (isHorizontal && isRtl) {\n          if (hasNegativeOffsetInRtl(root)) {\n            offset *= -1;\n          }\n        }\n        const prevOffset = store._getScrollOffset();\n        if (prevOffset === offset) {\n          return;\n        }\n        const scrollDirection = store._getScrollDirection();\n        // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n        // Scroll events are dispatched enough so it's ok to skip some of them.\n        if (\n          (scrollDirection === SCROLL_STOP || !resized) &&\n          // Ignore until manual scrolling\n          scrollDirection !== SCROLL_MANUAL\n        ) {\n          store._setScrollDirection(\n            prevOffset > offset ? SCROLL_UP : SCROLL_DOWN\n          );\n        }\n        resized = false;\n        store._update(ACTION_SCROLL, offset);\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._setScrollDirection(SCROLL_STOP);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      // Infer scroll state also from wheel events\n      // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n      const onWheel = throttle((e: WheelEvent) => {\n        if (store._getScrollDirection() === SCROLL_STOP) {\n          // Scroll start should be detected with scroll event\n          return;\n        }\n        if (e.ctrlKey) {\n          // Probably a pinch-to-zoom gesture\n          return;\n        }\n        // Get delta before checking deltaMode for firefox behavior\n        // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n        if (isHorizontal ? e.deltaX : e.deltaY) {\n          const offset = store._getScrollOffset();\n          if (\n            offset > 0 &&\n            offset < store._getScrollSize() - store._getViewportSize()\n          ) {\n            onScrollStopped();\n          }\n        }\n      }, 50);\n\n      ro.observe(root);\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        ro.disconnect();\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _initItem(el, i) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _getActualScrollSize: getActualScrollSize,\n    _scrollTo(offset) {\n      offset = max(offset, 0);\n\n      scrollManually(store._getItemIndexForScrollTo(offset), () => offset);\n    },\n    _scrollToIndex(index, count) {\n      index = max(min(index, count - 1), 0);\n\n      scrollManually(index, () => store._getItemOffset(index));\n    },\n    _fixScrollJump: (jump, startIndex) => {\n      const scrollDirection = store._getScrollDirection();\n      // Compensate scroll jump\n      if (scrollDirection === SCROLL_UP) {\n        const diff = calcTotalJump(jump);\n        if (diff) {\n          scrollTo(diff, true);\n        }\n      } else if (scrollDirection === SCROLL_MANUAL) {\n        const offset = store._getScrollOffset();\n        if (offset === 0) {\n          // Do nothing to stick to the start\n        } else {\n          const allDiff = calcTotalJump(jump);\n          if (\n            store._getScrollSize() -\n              (offset + store._getViewportSize() + allDiff) <=\n            0\n          ) {\n            // Keep end to stick to the end\n            if (allDiff) {\n              scrollTo(offset + allDiff);\n            }\n          } else {\n            // Keep start at mid\n            const diff = jump.reduce((acc, [index, j]) => {\n              if (index < startIndex) {\n                acc += j;\n              }\n              return acc;\n            }, 0);\n            if (diff) {\n              scrollTo(diff, true);\n            }\n          }\n        }\n      } else {\n        // NOP\n      }\n    },\n  };\n};\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import {\n  Children,\n  memo,\n  useRef,\n  useMemo,\n  CSSProperties,\n  ReactElement,\n  forwardRef,\n  useImperativeHandle,\n  ReactNode,\n  useEffect,\n  RefObject,\n  useState,\n  ReactFragment,\n} from \"react\";\nimport { VirtualStore, createVirtualStore } from \"../core/store\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { useStore } from \"./useStore\";\nimport { exists, max, min } from \"../core/utils\";\nimport { createScroller, Scroller } from \"../core/scroller\";\nimport { refKey } from \"./utils\";\nimport { useStatic } from \"./useStatic\";\nimport { useRefWithUpdate } from \"./useRefWithUpdate\";\n\ntype ItemProps = {\n  _children: ReactNode;\n  _scroller: Scroller;\n  _store: VirtualStore;\n  _index: number;\n  _element: \"div\";\n  _isOffscreen: boolean;\n};\n\nconst Item = memo(\n  ({\n    _children: children,\n    _scroller: scroller,\n    _store: store,\n    _index: index,\n    _element: Element,\n    _isOffscreen: isOffscreen,\n  }: ItemProps): ReactElement => {\n    const ref = useRef<HTMLDivElement>(null);\n\n    const offset = useStore(\n      store,\n      () => store._getItemOffset(index),\n      isOffscreen\n    );\n    const hide = useStore(\n      store,\n      () => store._isUnmeasuredItem(index),\n      isOffscreen\n    );\n\n    // The index may be changed if elements are inserted to or removed from the start of props.children\n    useIsomorphicLayoutEffect(\n      () => scroller._initItem(ref[refKey]!, index),\n      [index]\n    );\n\n    return (\n      <Element\n        ref={ref}\n        style={useMemo((): CSSProperties => {\n          const isHorizontal = store._isHorizontal();\n          const leftOrRightKey = store._isRtl() ? \"right\" : \"left\";\n          const style: CSSProperties = {\n            margin: 0,\n            padding: 0,\n            position: \"absolute\",\n            [isHorizontal ? \"height\" : \"width\"]: \"100%\",\n            [isHorizontal ? \"top\" : leftOrRightKey]: 0,\n            [isHorizontal ? leftOrRightKey : \"top\"]: offset,\n            visibility: hide || isOffscreen ? \"hidden\" : \"visible\",\n            // willChange: \"transform\",\n          };\n          if (isHorizontal) {\n            style.display = \"flex\";\n          }\n          return style;\n        }, [offset, hide, isOffscreen])}\n      >\n        {children}\n      </Element>\n    );\n  }\n);\n\nconst isInvalidElement = <T extends ReactNode>(\n  e: T\n): e is Extract<T, null | undefined | boolean> =>\n  !exists(e) || typeof e === \"boolean\";\n\nexport type WindowComponentAttributes = Pick<\n  React.HTMLAttributes<HTMLElement>,\n  \"className\" | \"style\" | \"id\" | \"role\" | \"tabIndex\"\n> &\n  React.AriaAttributes;\n\n/**\n * Props of customized scrollable component.\n */\nexport interface CustomWindowComponentProps {\n  children: ReactNode;\n  scrollSize: number;\n  scrolling: boolean;\n  horizontal: boolean;\n  attrs: WindowComponentAttributes;\n}\n\nconst DefaultWindow = forwardRef<any, CustomWindowComponentProps>(\n  (\n    { children, scrollSize, scrolling, horizontal, attrs },\n    ref\n  ): ReactElement => {\n    return (\n      <div ref={ref} {...attrs}>\n        <div\n          style={useMemo((): CSSProperties => {\n            return {\n              position: \"relative\",\n              visibility: \"hidden\",\n              width: horizontal ? scrollSize : \"100%\",\n              height: horizontal ? \"100%\" : scrollSize,\n              pointerEvents: scrolling ? \"none\" : \"auto\",\n            };\n          }, [scrollSize, scrolling])}\n        >\n          {children}\n        </div>\n      </div>\n    );\n  }\n);\n\nexport type CustomWindowComponent = typeof DefaultWindow;\n\nconst Window = ({\n  _children: children,\n  _ref: ref,\n  _store: store,\n  _element: Element,\n  _scrolling: scrolling,\n  _attrs: attrs,\n}: {\n  _children: ReactNode;\n  _ref: RefObject<HTMLDivElement>;\n  _store: VirtualStore;\n  _element: CustomWindowComponent;\n  _scrolling: boolean;\n  _attrs: WindowComponentAttributes;\n}) => {\n  const scrollSize = useStore(store, store._getScrollSize);\n\n  const horizontal = store._isHorizontal();\n\n  return (\n    <Element\n      ref={ref}\n      scrollSize={scrollSize}\n      scrolling={scrolling}\n      horizontal={horizontal}\n      attrs={useMemo(\n        () => ({\n          ...attrs,\n          style: {\n            overflow: horizontal ? \"auto hidden\" : \"hidden auto\",\n            contain: \"strict\",\n            // transform: \"translate3d(0px, 0px, 0px)\",\n            // willChange: \"scroll-position\",\n            // backfaceVisibility: \"hidden\",\n            width: \"100%\",\n            height: \"100%\",\n            padding: 0,\n            margin: 0,\n            ...attrs.style,\n          },\n        }),\n        [attrs]\n      )}\n    >\n      {children}\n    </Element>\n  );\n};\n\n/**\n * Props of customized item component.\n */\nexport interface CustomItemComponentProps {\n  style: CSSProperties;\n  children: ReactNode;\n}\n\nexport type CustomItemComponent = React.ForwardRefExoticComponent<\n  React.PropsWithoutRef<CustomItemComponentProps> & React.RefAttributes<any>\n>;\n\ntype CustomItemComponentOrElement =\n  | keyof JSX.IntrinsicElements\n  | CustomItemComponent;\n\n/**\n * Methods of {@link VList}.\n */\nexport interface VListHandle {\n  /**\n   * Get current scrollTop or scrollLeft.\n   */\n  readonly scrollOffset: number;\n  /**\n   * Get current scrollHeight or scrollWidth.\n   */\n  readonly scrollSize: number;\n  /**\n   * Get current offsetHeight or offsetWidth.\n   */\n  readonly viewportSize: number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   */\n  scrollToIndex(index: number): void;\n  /**\n   * Scroll to the given offset.\n   * @param offset offset from start\n   */\n  scrollTo(offset: number): void;\n  /**\n   * Scroll by the given offset.\n   * @param offset offset from current position\n   */\n  scrollBy(offset: number): void;\n}\n\n/**\n * Props of {@link VList}.\n */\nexport interface VListProps extends WindowComponentAttributes {\n  /**\n   * Elements rendered by this component.\n   */\n  children: ReactNode;\n  /**\n   * Item size hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.\n   * @defaultValue 40\n   */\n  itemSize?: number;\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan?: number;\n  /**\n   * If set, the specified amount of items will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.\n   */\n  initialItemCount?: number;\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal?: boolean;\n  /**\n   * You have to set true if you use this component under `direction: rtl` style.\n   */\n  rtl?: boolean;\n  /**\n   * Customized element type for scrollable element. This element will get {@link CustomWindowComponentProps} as props.\n   * @defaultValue {@link DefaultWindow}\n   */\n  element?: CustomWindowComponent;\n  /**\n   * Customized element type for item element. This element will get {@link CustomItemComponentProps} as props.\n   * @defaultValue \"div\"\n   */\n  itemElement?: CustomItemComponentOrElement;\n  /**\n   * Callback invoked whenever scroll offset changes.\n   * @param offset Current scrollTop or scrollLeft.\n   */\n  onScroll?: (offset: number) => void;\n  /**\n   * Callback invoked when scrolling stops.\n   */\n  onScrollStop?: () => void;\n  /**\n   * Callback invoked when visible items range changes.\n   */\n  onRangeChange?: (payload: {\n    /**\n     * The start index of viewable items.\n     */\n    start: number;\n    /**\n     * The end index of viewable items.\n     */\n    end: number;\n    /**\n     * The total count of items.\n     */\n    count: number;\n  }) => void;\n}\n\n/**\n * Virtualized list component. See {@link VListProps} and {@link VListHandle}.\n */\nexport const VList = forwardRef<VListHandle, VListProps>(\n  (\n    {\n      children,\n      itemSize: itemSizeProp = 40,\n      overscan = 4,\n      initialItemCount,\n      horizontal: horizontalProp,\n      rtl: rtlProp,\n      element = DefaultWindow,\n      itemElement = \"div\",\n      onScroll: onScrollProp,\n      onScrollStop: onScrollStopProp,\n      onRangeChange: onRangeChangeProp,\n      ...windowAttrs\n    },\n    ref\n  ): ReactElement => {\n    // Memoize element array\n    const elements = useMemo(() => {\n      const arr: (ReactElement | ReactFragment | string | number)[] = [];\n      Children.forEach(children, (e) => {\n        if (isInvalidElement(e)) {\n          return;\n        }\n        arr.push(e);\n      });\n      return arr;\n    }, [children]);\n    const count = elements.length;\n\n    const onScroll = useRefWithUpdate(onScrollProp);\n    const onScrollStop = useRefWithUpdate(onScrollStopProp);\n\n    const [mountedIndexes, reset] = useState<Set<number>>(new Set<number>());\n    const [scrolling, setScrolling] = useState(false);\n    // https://github.com/facebook/react/issues/25191#issuecomment-1237456448\n    const [store, scroller] = useStatic(() => {\n      const _store = createVirtualStore(\n        count,\n        itemSizeProp,\n        !!horizontalProp,\n        !!rtlProp,\n        initialItemCount,\n        (isScrolling) => {\n          setScrolling(isScrolling);\n          if (!isScrolling) {\n            reset(new Set());\n            onScrollStop[refKey] && onScrollStop[refKey]();\n          }\n        },\n        (offset) => {\n          onScroll[refKey] && onScroll[refKey](offset);\n        }\n      );\n      return [_store, createScroller(_store)];\n    });\n    // The elements length and cached items length are different just after element is added/removed.\n    store._updateCacheLength(count);\n\n    const [startIndex, endIndex] = useStore(store, store._getRange);\n    const jump = useStore(store, store._getJump);\n    const rootRef = useRef<HTMLDivElement>(null);\n\n    useIsomorphicLayoutEffect(() => scroller._initRoot(rootRef[refKey]!), []);\n\n    useIsomorphicLayoutEffect(() => {\n      if (!jump.length) return;\n\n      scroller._fixScrollJump(jump, startIndex);\n    }, [jump]);\n\n    useEffect(() => {\n      if (!onRangeChangeProp) return;\n\n      onRangeChangeProp({\n        start: startIndex,\n        end: endIndex,\n        count,\n      });\n    }, [startIndex, endIndex]);\n\n    useImperativeHandle(\n      ref,\n      () => {\n        return {\n          get scrollOffset() {\n            return store._getScrollOffset();\n          },\n          get scrollSize() {\n            return scroller._getActualScrollSize();\n          },\n          get viewportSize() {\n            return store._getViewportSize();\n          },\n          scrollToIndex(index) {\n            scroller._scrollToIndex(index, count);\n          },\n          scrollTo: scroller._scrollTo,\n          scrollBy(offset) {\n            scroller._scrollTo(store._getScrollOffset() + offset);\n          },\n        };\n      },\n      [count]\n    );\n\n    const startIndexWithMargin = max(startIndex - overscan, 0);\n    const endIndexWithMargin = min(endIndex + overscan, count - 1);\n    const items = useMemo(() => {\n      const res: ReactElement[] = [];\n      for (let i = startIndexWithMargin; i <= endIndexWithMargin; i++) {\n        // https://github.com/sergi/virtual-list/commit/8e7e06dc63568334c1ab809ea83c1be36572e9ed\n        mountedIndexes.add(i);\n      }\n      mountedIndexes.forEach((i) => {\n        const e = elements[i];\n        // This can be undefined when items are removed\n        if (exists(e)) {\n          res.push(\n            <Item\n              key={(e as { key?: ReactElement[\"key\"] })?.key || i}\n              _scroller={scroller}\n              _store={store}\n              _index={i}\n              _element={itemElement as \"div\"}\n              _children={e}\n              _isOffscreen={i < startIndexWithMargin || i > endIndexWithMargin}\n            />\n          );\n        }\n      });\n      return res;\n    }, [elements, mountedIndexes, startIndexWithMargin, endIndexWithMargin]);\n\n    return (\n      <Window\n        _ref={rootRef}\n        _store={store}\n        _element={element}\n        _scrolling={scrolling}\n        _children={items}\n        _attrs={windowAttrs}\n      />\n    );\n  }\n);\n"],"names":["min","max","now","exists","v","range","length","cb","_","i","debounce","fn","ms","id","cancel","debouncedFn","throttle","time","args","n","once","called","cache","UNCACHED","getItemSize","index","size","setItemSize","computeOffset","isTotal","top","computeTotalSize","computeStartOffset","findIndex","distance","sum","h","findStartIndexWithOffset","offset","prevStartIndex","prevOffset","findEndIndex","hasUnmeasuredItemsInRange","startIndex","endIndex","resetCache","itemSize","SCROLL_STOP","SCROLL_DOWN","SCROLL_UP","SCROLL_MANUAL","ACTION_ITEM_RESIZE","ACTION_WINDOW_RESIZE","ACTION_SCROLL","ACTION_MANUAL_SCROLL","createVirtualStore","itemCount","isHorizontal","isRtl","initialItemCount","onScrollStateChange","onScrollOffsetChange","viewportSize","scrollOffset","jump","scrollDirection","_prevRange","_scrollToQueue","subscribers","prevEndIndex","start","end","resolve","reject","type","payload","updated","updatedJump","dir","prev","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","refKey","useRefWithUpdate","value","ref","useRef","useStore","store","getSnapShot","disabled","getter","state","setState","useState","update","sync","flushSync","hasNegativeOffsetInRtl","scrollable","key","isNegative","createScroller","resized","rootElement","scrollToKey","sizeKey","mountedIndexes","getResizeObserver","entries","resizes","target","contentRect","getActualScrollSize","scrollTo","diff","scrollManually","getCurrentOffset","getOffset","scrollSize","calcTotalJump","acc","j","root","ro","syncViewportToScrollPosition","onScrollStopped","onScroll","onWheel","e","el","count","allDiff","useStatic","init","Item","memo","children","scroller","Element","isOffscreen","hide","jsx","useMemo","leftOrRightKey","style","isInvalidElement","DefaultWindow","forwardRef","scrolling","horizontal","attrs","Window","VList","itemSizeProp","overscan","horizontalProp","rtlProp","element","itemElement","onScrollProp","onScrollStopProp","onRangeChangeProp","windowAttrs","elements","arr","Children","onScrollStop","reset","setScrolling","_store","isScrolling","rootRef","useImperativeHandle","startIndexWithMargin","endIndexWithMargin","items","res"],"mappings":"+HAAO,MAAMA,EAAM,KAAK,IACXC,EAAM,KAAK,IACXC,EAAM,KAAK,IAEXC,EAAaC,GAA4CA,GAAK,KAE9DC,EAAQ,CAAIC,EAAgBC,IACvC,MAAM,KAAK,CAAE,OAAAD,CAAO,EAAG,CAACE,EAAGC,IAAMF,EAAGE,CAAC,CAAC,EAE3BC,GAAW,CACtBC,EACAC,IACG,CACC,IAAAC,EAEJ,MAAMC,EAAS,IAAM,CACfX,EAAOU,CAAE,GACX,aAAaA,CAAE,CACjB,EAEIE,EAAc,IAAM,CACjBD,IACPD,EAAK,WAAW,IAAM,CACfA,EAAA,KACFF,KACFC,CAAE,CAAA,EAEP,OAAAG,EAAY,QAAUD,EACfC,CACT,EAEaC,GAAW,CACtBL,EACAC,IACG,CACC,IAAAK,EAAOf,EAAQ,EAAAU,EACnB,MAAO,IAAIM,IAAwB,CACjC,MAAMC,EAAIjB,IACNe,EAAOL,EAAKO,IACPF,EAAAE,EACPR,EAAG,GAAGO,CAAI,EACZ,CAEJ,EAEaE,GAA2CT,GAAa,CAC/D,IAAAU,EACAC,EAEJ,MAAQ,IAAIJ,KACLG,IACMA,EAAA,GACDC,EAAAX,EAAG,GAAGO,CAAI,GAEbI,EAEX,ECrDaC,EAAW,GAUXC,EAAc,CAACF,EAAcG,IAA0B,CAC5D,MAAAC,EAAOJ,EAAM,OAAOG,CAAK,EACxB,OAAAC,IAASH,EAAWD,EAAM,iBAAmBI,CACtD,EAEaC,GAAc,CACzBL,EACAG,EACAC,IACG,CACGJ,EAAA,OAAOG,CAAK,EAAIC,EAEtBJ,EAAM,qBAAuBtB,EAAIyB,EAAOH,EAAM,oBAAoB,CACpE,EAEMM,GAAgB,CACpBN,EACAG,EACAI,IACW,CACX,GAAI,CAACP,EAAM,QAAgB,MAAA,GACvB,GAAAA,EAAM,sBAAwBG,EAChC,OAAII,EACKP,EAAM,SAASG,CAAK,EAAKD,EAAYF,EAAOG,CAAK,EAEjDH,EAAM,SAASG,CAAK,EAI/B,IAAIhB,EAAIa,EAAM,qBACVQ,EAAMR,EAAM,SAASb,CAAC,EAC1B,KAAOA,GAAKgB,IACJH,EAAA,SAASb,CAAC,EAAIqB,EAChB,EAAArB,IAAMgB,GAAS,CAACI,KAGbC,GAAAN,EAAYF,EAAOb,CAAC,EAC3BA,IAGF,OAAAa,EAAM,qBAAuBG,EACtBK,CACT,EAEaC,GAAoBT,GACxBM,GAAcN,EAAOA,EAAM,QAAU,EAAG,EAAI,EAGxCU,EAAqB,CAChCV,EACAG,IAEOG,GAAcN,EAAOG,CAAK,EAG7BQ,GAAY,CAACX,EAAcb,EAAWyB,IAA6B,CACvE,IAAIC,EAAM,EACV,GAAID,GAAY,EAEP,KAAAzB,EAAIa,EAAM,QAAU,GAAG,CACtB,MAAAc,EAAIZ,EAAYF,EAAOb,GAAG,EAC3B,IAAA0B,GAAOC,IAAMF,EAAU,CACtBC,EAAMC,EAAI,GAAKF,GACjBzB,IAEF,WAKJ,MAAOA,EAAI,GAAG,CACZ,MAAM2B,EAAIZ,EAAYF,EAAO,EAAEb,CAAC,EAC3B,IAAA0B,GAAOC,IAAMF,EAAU,CACtBC,EAAMC,EAAI,EAAIF,GAChBzB,IAEF,OAKN,OAAOT,EAAIC,EAAIQ,EAAG,CAAC,EAAGa,EAAM,QAAU,CAAC,CACzC,EAEae,EAA2B,CACtCf,EACAgB,EACAC,EACAC,IAEOP,GAAUX,EAAOiB,EAAgBD,EAASE,CAAU,EAGhDC,EAAeR,GAEfS,GAA4B,CACvCpB,EACAqB,EACAC,IACY,CACZ,QAASnC,EAAIkC,EAAYlC,GAAKmC,EAAUnC,IACtC,GAAIa,EAAM,OAAOb,CAAC,IAAMc,EACf,MAAA,GAGJ,MAAA,EACT,EAEasB,GAAa,CACxBvC,EACAwC,EACAxB,KAEO,CACL,iBAAkBwB,EAClB,QAASxC,EACT,qBAAsBgB,EAClBtB,EAAIsB,EAAM,qBAAsBhB,EAAS,CAAC,EAC1C,EACJ,OAAQD,EAAMC,EAASG,GAAM,CAC3B,MAAMiB,EAAOJ,GAASA,EAAM,OAAOb,CAAC,EAChC,OAAAN,EAAOuB,CAAI,EACNA,EAEFH,CAAA,CACR,EACD,SAAUlB,EAAMC,EAASG,GAAM,CAC7B,GAAIA,IAAM,EAED,MAAA,GAET,MAAM6B,EAAShB,GAASA,EAAM,SAASb,CAAC,EACpC,OAAAN,EAAOmC,CAAM,EACRA,EAEFf,CAAA,CACR,CAAA,GClIQwB,EAAc,EACdC,GAAc,EACdC,EAAY,EACZC,EAAgB,EAOhBC,EAAqB,EACrBC,GAAuB,EACvBC,EAAgB,EAChBC,EAAuB,EA8BvBC,GAAqB,CAChCC,EACAV,EACAW,EACAC,EACAC,EAA2B,EAC3BC,EACAC,IACiB,CACjB,IAAIC,EAAehB,EAAW7C,EAAI0D,EAAmB,EAAG,CAAC,EACrDI,EAAe,EACfC,EAAmB,CAAA,EACnB1C,EAAQuB,GAAWW,EAAWV,CAAQ,EACtCmB,EAAmClB,EACnCmB,EAAyB,CAAC,EAAGP,CAAgB,EAC7CQ,EAEE,MAAAC,MAAkB,IAEjB,MAAA,CACL,WAAY,CACJ,KAAA,CAAC7B,EAAgB8B,CAAY,EAAIH,EACjC1B,EAAaR,EACjBV,EACAiB,CAAA,EAEI+B,EAAQjC,EACZf,EACAyC,EACAxB,EACAC,CAAA,EAEI+B,EAAM9B,EAAanB,EAAOgD,EAAOR,CAAY,EAC/C,OAAAvB,IAAmB+B,GAASD,IAAiBE,EACxCL,EAEDA,EAAa,CAACI,EAAOC,CAAG,CAClC,EACA,kBAAkB9C,EAAO,CAChB,OAAAH,EAAM,OAAOG,CAAK,IAAMF,CACjC,EACA,2BAA2BoB,EAAY,CAC9B,OAAAD,GACLpB,EACAqB,EACAF,EAAanB,EAAOqB,EAAYmB,CAAY,CAAA,CAEhD,EACA,eAAerC,EAAO,CACb,OAAAO,EAAmBV,EAA2BG,CAAK,CAC5D,EACA,kBAAmB,CACV,OAAAsC,CACT,EACA,kBAAmB,CACV,OAAAD,CACT,EACA,gBAAiB,CACf,OAAO/B,GAAiBT,CAAyB,CACnD,EACA,UAAW,CACF,OAAA0C,CACT,EACA,eAAgB,CACP,OAAAP,CACT,EACA,QAAS,CACA,OAAAC,CACT,EACA,yBAAyBpB,EAAQ,CAC/B,OAAOD,EAAyBf,EAAOgB,EAAQ,EAAG,CAAC,CACrD,EACA,wCAAyC,CACvC,OAAI6B,GAEFA,EAAe,CAAC,IAIX,IAAI,QAAQ,CAACK,EAASC,IAAW,CACrBN,EAAA,CACf,IAAM,CAEI,QAAA,UAAU,KAAK,IAAM,CACnBK,IACSL,EAAA,MAAA,CAClB,CACH,EACAM,CAAA,CACF,CACD,CACH,EACA,WAAWlE,EAAI,CACb,OAAA6D,EAAY,IAAI7D,CAAE,EACX,IAAM,CACX6D,EAAY,OAAO7D,CAAE,CAAA,CAEzB,EACA,QAAQmE,EAAMC,EAAS,EACJ,IAAe,CAC9B,OAAQD,EAAM,CACZ,KAAKvB,EAAoB,CACvB,MAAMyB,EAAUD,EAAQ,OACtB,CAAC,CAAClD,EAAOC,CAAI,IAAMJ,EAAM,OAAOG,CAAK,IAAMC,CAAA,EAGzC,GAAA,CAACkD,EAAQ,OACJ,MAAA,GAGT,MAAMC,EAAmD,CAAA,EACzD,OAAAD,EAAQ,QAAQ,CAAC,CAACnD,EAAOC,CAAI,IAAM,CACrBmD,EAAA,KAAK,CAACpD,EAAOC,EAAOF,EAAYF,EAAOG,CAAK,CAAC,CAAC,EAC9CE,GAAAL,EAA2BG,EAAOC,CAAI,CAAA,CACnD,EACMsC,EAAAa,EACA,EACT,CACA,KAAKzB,GACH,OAAIU,IAAiBa,EACZ,IAEMb,EAAAa,EACR,IAET,KAAKtB,EACL,KAAKC,EAAsB,CACzB,MAAMd,EAAauB,EACnB,OAAQA,EAAeY,KAAanC,CACtC,CACF,CAAA,OAIY4B,EAAA,QAAS7D,GAAO,CAC1BA,EACEmE,IAASvB,GAAsBuB,IAASrB,CAAuB,CACjE,CACD,EAEGqB,IAASrB,EACXQ,EAAqBE,CAAY,EACxBI,GAAkBO,IAASvB,GACpCgB,EAAe,CAAC,IAGtB,EACA,qBAAsB,CACb,OAAAF,CACT,EACA,oBAAoBa,EAAK,CACvB,MAAMC,EAAOd,EACKA,EAAAa,EACdb,IAAoBlB,EACtBa,EAAoB,EAAK,EAEzBmB,IAAShC,IACRkB,IAAoBjB,IAAeiB,IAAoBhB,IAExDW,EAAoB,EAAI,CAE5B,EACA,mBAAmBtD,EAAQ,CAErBgB,EAAM,UAAYhB,IACdgB,EAAAuB,GAAWvC,EAAQwC,EAAUxB,CAAK,EAC5C,CAAA,CAEJ,ECnOa0D,EACX,OAAO,OAAW,IAAcC,EAAkB,gBAAAC,EAAA,UCJvCC,EAAS,UCITC,EAAuBC,GAAa,CACzC,MAAAC,EAAMC,SAAUF,CAAK,EAE3B,OAAAL,EAA0B,IAAM,CAC9BM,EAAIH,CAAM,EAAIE,CAAA,EACb,CAACA,CAAK,CAAC,EAEHC,CACT,ECNaE,EAAW,CACtBC,EACAC,EACAC,IACM,CACA,MAAAC,EAASR,EAAiBM,CAAW,EACrC,CAACG,EAAOC,CAAQ,EAAIC,WAASL,CAAW,EAE9CT,OAAAA,EAAAA,gBAAgB,IAAM,CAChB,GAAAU,EAAU,OAEd,MAAMK,EAAS,IAAM,CACVF,EAAAF,EAAOT,CAAM,CAAC,CAAA,EAElB,OAAAM,EAAM,WAAYQ,GAAS,CAC5BA,EACFC,GAAA,UAAUF,CAAM,EAETA,GACT,CACD,CAAA,EACA,CAACL,CAAQ,CAAC,EAENE,CACT,ECbMM,GAAyB/E,GAAMgF,GAA4B,CAC/D,MAAMC,EAAM,aACNtB,EAAOqB,EAAWC,CAAG,EAC3BD,EAAWC,CAAG,EAAI,EACZ,MAAAC,EAAaF,EAAWC,CAAG,IAAM,EACvC,OAAAD,EAAWC,CAAG,EAAItB,EACXuB,CACT,CAAC,EAWYC,GAAkBd,GAAkC,CAC/D,IAAIe,EAAU,GACVC,EACE,MAAAhD,EAAegC,EAAM,gBACrB/B,EAAQ+B,EAAM,SACdiB,EAAcjD,EAAe,aAAe,YAC5CkD,EAAUlD,EAAe,QAAU,SACnCmD,MAAqB,QAGrBC,EAAoBzF,GAAK,IACtB,IAAI,eAAgB0F,GAAY,CAErC,MAAMC,EAAwB,CAAA,EAC9B,SAAW,CAAE,OAAAC,EAAQ,YAAAC,CAAY,IAAKH,EACpC,GAAIE,IAAWP,EACbhB,EAAM,QAAQrC,GAAsB6D,EAAYN,CAAO,CAAC,MACnD,CACC,MAAAlF,EAAQmF,EAAe,IAAII,CAAM,EACnC7G,EAAOsB,CAAK,GACdsF,EAAQ,KAAK,CAACtF,EAAOwF,EAAYN,CAAO,CAAC,CAAC,EAK5CI,EAAQ,SACJtB,EAAA,QAAQtC,EAAoB4D,CAAO,EAC/BP,EAAA,GACZ,CACD,CACF,EACKU,EAAsB,IACrBT,EAGEhD,EAAegD,EAAY,YAAcA,EAAY,aAHnC,EAKrBU,EAAW,CAAC7E,EAAgB8E,IAAmB,CAC9CX,IACDhD,GAAgBC,GACdyC,GAAuBM,CAAW,IAC1BnE,GAAA,IAGV8E,EACFX,EAAYC,CAAW,GAAKpE,GAE5BmE,EAAYC,CAAW,EAAIpE,EAC3BmD,EAAM,oBAAoBvC,CAAa,GACzC,EAEImE,EAAiB,MACrB5F,EACA6F,IACG,CACH,MAAMC,EAAY,IAAc,CAC9B,IAAIjF,EAASgF,IACb,MAAME,EAAaN,IACbpD,EAAe2B,EAAM,mBACvB,OAAA+B,GAAclF,EAASwB,IAAiB,IAE1CxB,EAASkF,EAAa1D,GAEjBxB,CAAA,EAGL,GAAAmD,EAAM,2BAA2BhE,CAAK,EAAG,CACxC,EAAA,CAEKgE,EAAA,QAAQnC,EAAsBiE,EAAW,CAAA,EAC3C,GAAA,CAEF,MAAM9B,EAAM,+CAGZ,MACF,QACOA,EAAM,2BAA2BhE,CAAK,GAG/C0F,EAASI,GAAW,MACf,CACL,MAAMjF,EAASiF,IACfJ,EAAS7E,CAAM,EAETmD,EAAA,QAAQnC,EAAsBhB,CAAM,EAC5C,EAGImF,EAAiBzD,GACrBA,EAAK,OAAO,CAAC0D,EAAK,CAAA,CAAGC,CAAC,IAAMD,EAAMC,EAAG,CAAC,EAEjC,MAAA,CACL,UAAUC,EAAM,CACAnB,EAAAmB,EACd,MAAMC,EAAKhB,IAELiB,EAA+B,IAAM,CACrC,IAAAxF,EAASsF,EAAKlB,CAAW,EACzBjD,GAAgBC,GACdyC,GAAuByB,CAAI,IACnBtF,GAAA,IAGR,MAAAE,EAAaiD,EAAM,mBACzB,GAAIjD,IAAeF,EACjB,OAEI,MAAA2B,EAAkBwB,EAAM,uBAI3BxB,IAAoBlB,GAAe,CAACyD,IAErCvC,IAAoBf,GAEduC,EAAA,oBACJjD,EAAaF,EAASW,EAAYD,EAAA,EAG5BwD,EAAA,GACJf,EAAA,QAAQpC,EAAef,CAAM,CAAA,EAG/ByF,EAAkBrH,GAAS,IAAM,CAERoH,IAC7BrC,EAAM,oBAAoB1C,CAAW,GACpC,GAAG,EAEAiF,EAAW,IAAM,CACQF,IACbC,GAAA,EAKZE,EAAUjH,GAAUkH,GAAkB,CACtC,GAAAzC,EAAM,oBAAoB,IAAM1C,GAIhC,CAAAmF,EAAE,UAOFzE,EAAeyE,EAAE,OAASA,EAAE,QAAQ,CAChC,MAAA5F,EAASmD,EAAM,mBAEnBnD,EAAS,GACTA,EAASmD,EAAM,iBAAmBA,EAAM,oBAExBsC,MAGnB,EAAE,EAEL,OAAAF,EAAG,QAAQD,CAAI,EACVA,EAAA,iBAAiB,SAAUI,CAAQ,EACxCJ,EAAK,iBAAiB,QAASK,EAAS,CAAE,QAAS,GAAM,EAElD,IAAM,CACXJ,EAAG,WAAW,EACTD,EAAA,oBAAoB,SAAUI,CAAQ,EACtCJ,EAAA,oBAAoB,QAASK,CAAO,EACzCF,EAAgB,QAAQ,CAAA,CAE5B,EACA,UAAUI,EAAI1H,EAAG,CACf,MAAMoH,EAAKhB,IACI,OAAAD,EAAA,IAAIuB,EAAI1H,CAAC,EACxBoH,EAAG,QAAQM,CAAE,EACN,IAAM,CACXvB,EAAe,OAAOuB,CAAE,EACxBN,EAAG,UAAUM,CAAE,CAAA,CAEnB,EACA,qBAAsBjB,EACtB,UAAU5E,EAAQ,CACPA,EAAArC,EAAIqC,EAAQ,CAAC,EAEtB+E,EAAe5B,EAAM,yBAAyBnD,CAAM,EAAG,IAAMA,CAAM,CACrE,EACA,eAAeb,EAAO2G,EAAO,CAC3B3G,EAAQxB,EAAID,EAAIyB,EAAO2G,EAAQ,CAAC,EAAG,CAAC,EAEpCf,EAAe5F,EAAO,IAAMgE,EAAM,eAAehE,CAAK,CAAC,CACzD,EACA,eAAgB,CAACuC,EAAMrB,IAAe,CAC9B,MAAAsB,EAAkBwB,EAAM,sBAE9B,GAAIxB,IAAoBhB,EAAW,CAC3B,MAAAmE,EAAOK,EAAczD,CAAI,EAC3BoD,GACFD,EAASC,EAAM,EAAI,UAEZnD,IAAoBf,EAAe,CACtC,MAAAZ,EAASmD,EAAM,mBACrB,GAAInD,IAAW,EAER,CACC,MAAA+F,EAAUZ,EAAczD,CAAI,EAEhC,GAAAyB,EAAM,kBACHnD,EAASmD,EAAM,iBAAiB,EAAI4C,IACvC,EAGIA,GACFlB,EAAS7E,EAAS+F,CAAO,MAEtB,CAEC,MAAAjB,EAAOpD,EAAK,OAAO,CAAC0D,EAAK,CAACjG,EAAOkG,CAAC,KAClClG,EAAQkB,IACH+E,GAAAC,GAEFD,GACN,CAAC,EACAN,GACFD,EAASC,EAAM,EAAI,IAO7B,CAAA,CAEJ,ECxQakB,GAAgBC,GAAqB,CAChD,MAAMjD,EAAMC,EAAAA,SACZ,OAAOD,EAAIH,CAAM,IAAMG,EAAIH,CAAM,EAAIoD,EAAK,EAC5C,EC2BAC,GAAAC,EAAA,KAAa,CAAA,CACV,UAAAC,EACY,UAAAC,EACA,OAAAlD,EACH,OAAAhE,EACA,SAAAmH,EACE,aAAAC,CACI,IAAA,CAEd,MAAAvD,EAAAC,SAAA,IAAA,EAEAjD,EAAAkD,EAAeC,EACb,IAAAA,EAAA,eAAAhE,CAAA,EACgCoH,CAChC,EAEFC,EAAAtD,EAAaC,EACX,IAAAA,EAAA,kBAAAhE,CAAA,EACmCoH,CACnC,EAIF,OAAA7D,EAAA,IAAA2D,EAAA,UAAArD,EAAAH,CAAA,EAAA1D,CAAA,EAC8C,CAAAA,CAAA,CACtC,EAGRsH,EACEH,EAAC,CAAA,IAAAtD,EACC,MAAA0D,EAAA,QAAA,IAAA,CAEE,MAAAvF,EAAAgC,EAAA,gBACAwD,EAAAxD,EAAA,OAAA,EAAA,QAAA,OACAyD,EAAA,CAA6B,OAAA,EACnB,QAAA,EACC,SAAA,WACC,CAAAzF,EAAA,SAAA,OAAA,EAAA,OAC2B,CAAAA,EAAA,MAAAwF,CAAA,EAAA,EACI,CAAAxF,EAAAwF,EAAA,KAAA,EAAA3G,EACA,WAAAwG,GAAAD,EAAA,SAAA,SACI,EAG/C,OAAApF,IACEyF,EAAA,QAAA,QAEFA,CAAO,EAAA,CAAA5G,EAAAwG,EAAAD,CAAA,CAAA,EACqB,SAAAH,CAE7B,CAAA,CACH,CAGN,EAEAS,GAAA,GAAA,CAAAhJ,EAAA,CAAA,GAAA,OAAA,GAAA,UAsBAiJ,GAAAC,EAAA,WAAsB,CAAA,CAAA,SAAAX,EAAA,WAAAlB,EAAA,UAAA8B,EAAA,WAAAC,EAAA,MAAAC,CAAA,EAAAlE,IAKlByD,EAAA,MAAA,CAAA,IAAAzD,EAAA,GAAAkE,EAAA,SAAAT,EAEI,MAAC,CAAA,MAAAC,EAAA,QAAA,KAEG,CAAO,SAAA,WACK,WAAA,SACE,MAAAO,EAAA/B,EAAA,OACqB,OAAA+B,EAAA,OAAA/B,EACH,cAAA8B,EAAA,OAAA,MACM,GACtC,CAAA9B,EAAA8B,CAAA,CAAA,EACwB,SAAAZ,CAEzB,CAAA,CAAA,CAAA,CAKX,EAIAe,GAAA,CAAA,CAAgB,UAAAf,EACH,KAAApD,EACL,OAAAG,EACE,SAAAmD,EACE,WAAAU,EACE,OAAAE,CAEd,IAAA,CAQE,MAAAhC,EAAAhC,EAAAC,EAAAA,EAAA,cAAA,EAEA8D,EAAA9D,EAAA,gBAEA,OAAAsD,EACEH,EAAC,CAAA,IAAAtD,EACC,WAAAkC,EACA,UAAA8B,EACA,WAAAC,EACA,MAAAP,EAAA,QACO,KAAA,CACE,GAAAQ,EACF,MAAA,CACI,SAAAD,EAAA,cAAA,cACkC,QAAA,SAC9B,MAAA,OAIF,OAAA,OACC,QAAA,EACC,OAAA,EACD,GAAAC,EAAA,KACC,CACX,GACF,CAAAA,CAAA,CACM,EACR,SAAAd,CAEC,CAAA,CAGP,EA0HOgB,GAAAL,EAAA,WAAc,CAAA,CAEjB,SAAAX,EACE,SAAAiB,EAAA,GACyB,SAAAC,EAAA,EACd,iBAAAjG,EACX,WAAAkG,EACY,IAAAC,EACP,QAAAC,EAAAX,GACK,YAAAY,EAAA,MACI,SAAAC,EACJ,aAAAC,EACI,cAAAC,EACC,GAAAC,CACZ,EAAA9E,IAAA,CAKL,MAAA+E,EAAArB,EAAAA,QAAA,IAAA,CACE,MAAAsB,EAAA,CAAA,EACAC,OAAAA,EAAAA,SAAA,QAAA7B,EAAAR,GAAA,CACEiB,GAAAjB,CAAA,GAGAoC,EAAA,KAAApC,CAAA,CAAU,CAAA,EAEZoC,CAAO,EAAA,CAAA5B,CAAA,CAAA,EAETN,EAAAiC,EAAA,OAEArC,EAAA5C,EAAA6E,CAAA,EACAO,EAAApF,EAAA8E,CAAA,EAEA,CAAAtD,EAAA6D,CAAA,EAAA1E,EAAAA,SAAA,IAAA,GAAA,EACA,CAAAuD,EAAAoB,CAAA,EAAA3E,EAAA,SAAA,EAAA,EAEA,CAAAN,EAAAkD,CAAA,EAAAL,GAAA,IAAA,CACE,MAAAqC,EAAApH,GAAe6E,EACbuB,EACA,CAAA,CAAAE,EACE,CAAA,CAAAC,EACAnG,EACFiH,GAAA,CAEEF,EAAAE,CAAA,EACAA,IACEH,EAAA,IAAA,GAAA,EACAD,EAAArF,CAAA,GAAAqF,EAAArF,CAAA,EAAA,EACF,EACF7C,GAAA,CAEE0F,EAAA7C,CAAA,GAAA6C,EAAA7C,CAAA,EAAA7C,CAAA,CAA2C,CAC7C,EAEF,MAAA,CAAAqI,EAAApE,GAAAoE,CAAA,CAAA,CAAsC,CAAA,EAGxClF,EAAA,mBAAA2C,CAAA,EAEA,KAAA,CAAAzF,EAAAC,CAAA,EAAA4C,EAAAC,EAAAA,EAAA,SAAA,EACAzB,EAAAwB,EAAAC,EAAAA,EAAA,QAAA,EACAoF,EAAAtF,SAAA,IAAA,EAEAP,EAAA,IAAA2D,EAAA,UAAAkC,EAAA1F,CAAA,CAAA,EAAA,CAAA,CAAA,EAEAH,EAAA,IAAA,CACEhB,EAAA,QAEA2E,EAAA,eAAA3E,EAAArB,CAAA,CAAwC,EAAA,CAAAqB,CAAA,CAAA,EAG1CkB,EAAAA,UAAA,IAAA,CACEiF,GAEAA,EAAA,CAAkB,MAAAxH,EACT,IAAAC,EACF,MAAAwF,CACL,CAAA,CACD,EAAA,CAAAzF,EAAAC,CAAA,CAAA,EAGHkI,EAAA,oBAAAxF,EACE,KAEE,CAAO,IAAA,cAAA,CAEH,OAAAG,EAAA,kBAA8B,EAChC,IAAA,YAAA,CAEE,OAAAkD,EAAA,sBAAqC,EACvC,IAAA,cAAA,CAEE,OAAAlD,EAAA,kBAA8B,EAChC,cAAAhE,EAAA,CAEEkH,EAAA,eAAAlH,EAAA2G,CAAA,CAAoC,EACtC,SAAAO,EAAA,UACmB,SAAArG,EAAA,CAEjBqG,EAAA,UAAAlD,EAAA,iBAAA,EAAAnD,CAAA,CAAoD,CACtD,GAEJ,CAAA8F,CAAA,CACM,EAGR,MAAA2C,EAAA9K,EAAA0C,EAAAiH,EAAA,CAAA,EACAoB,EAAAhL,EAAA4C,EAAAgH,EAAAxB,EAAA,CAAA,EACA6C,GAAAjC,EAAAA,QAAA,IAAA,CACE,MAAAkC,EAAA,CAAA,EACA,QAAAzK,EAAAsK,EAAAtK,GAAAuK,EAAAvK,IAEEmG,EAAA,IAAAnG,CAAA,EAEF,OAAAmG,EAAA,QAAAnG,GAAA,CACE,MAAAyH,EAAAmC,EAAA5J,CAAA,EAEAN,EAAA+H,CAAA,GACEgD,EAAA,KAAInC,EACFP,GAAC,CAAA,UAAAG,EAEY,OAAAlD,EACH,OAAAhF,EACA,SAAAuJ,EACE,UAAA9B,EACC,aAAAzH,EAAAsK,GAAAtK,EAAAuK,CACmC,GAAA9C,GAAA,YAAAA,EAAA,MAAAzH,CANI,CAOpD,CAEJ,CAAA,EAEFyK,CAAO,EAAA,CAAAb,EAAAzD,EAAAmE,EAAAC,CAAA,CAAA,EAGT,OAAAjC,EACEU,GAAC,CAAA,KAAAoB,EACO,OAAApF,EACE,SAAAsE,EACE,WAAAT,EACE,UAAA2B,GACD,OAAAb,CACH,CAAA,CACV,CAGN;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}