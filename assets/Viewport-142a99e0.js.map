{"version":3,"file":"Viewport-142a99e0.js","sources":["../../src/core/utils.ts","../../src/core/cache.ts","../../src/core/store.ts","../../src/react/useIsomorphicLayoutEffect.ts","../../src/react/utils.ts","../../src/react/useLatestRef.ts","../../src/react/useSelector.ts","../../src/core/environment.ts","../../src/core/scroller.ts","../../src/react/useStatic.ts","../../src/core/resizer.ts","../../src/react/Viewport.tsx"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const abs = Math.abs;\nexport const now = Date.now;\nexport const values = Object.values;\nexport const timeout = setTimeout;\n\nexport const clamp = (\n  value: number,\n  minValue: number,\n  maxValue: number\n): number => min(maxValue, max(minValue, value));\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const median = (arr: number[]): number => {\n  const s = [...arr].sort((a, b) => a - b);\n  const mid = (arr.length / 2) | 0;\n  return s.length % 2 === 0 ? (s[mid - 1]! + s[mid]!) / 2 : s[mid]!;\n};\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: NodeJS.Timeout | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = timeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n\n// wrap for SSR\nexport const computeStyle = (e: HTMLElement) => getComputedStyle(e);\n\nexport const getStyleNumber = (v: string): number => {\n  if (v) {\n    return parseFloat(v);\n  } else {\n    return 0;\n  }\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { clamp, median, min } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _measuredOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n): boolean => {\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._measuredOffsetIndex = min(index, cache._measuredOffsetIndex);\n  return isInitialMeasurement;\n};\n\nexport const computeOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  if (!cache._length) return 0;\n  if (cache._measuredOffsetIndex >= index) {\n    return cache._offsets[index]!;\n  }\n\n  let i = cache._measuredOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i < index) {\n    top += getItemSize(cache, i);\n    cache._offsets[++i] = top;\n  }\n  // mark as measured\n  cache._measuredOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  if (!cache._length) return 0;\n  return (\n    computeOffset(cache, cache._length - 1) +\n    getItemSize(cache, cache._length - 1)\n  );\n};\n\nexport const findIndex = (\n  cache: Cache,\n  i: number,\n  distance: number\n): number => {\n  let sum = 0;\n  if (distance >= 0) {\n    // search forward\n    while (i < cache._length - 1) {\n      const h = getItemSize(cache, i++);\n      if ((sum += h) >= distance) {\n        if (sum - h / 2 >= distance) {\n          i--;\n        }\n        break;\n      }\n    }\n  } else {\n    // search backward\n    while (i > 0) {\n      const h = getItemSize(cache, --i);\n      if ((sum -= h) <= distance) {\n        if (sum + h / 2 < distance) {\n          i++;\n        }\n        break;\n      }\n    }\n  }\n\n  return clamp(i, 0, cache._length - 1);\n};\n\nexport const findStartIndexWithOffset = (\n  cache: Writeable<Cache>,\n  offset: number,\n  initialIndex: number\n): number => {\n  return findIndex(\n    cache,\n    initialIndex,\n    offset - computeOffset(cache, initialIndex)\n  );\n};\n\nexport const hasUnmeasuredItemsInRange = (\n  cache: Cache,\n  startIndex: number,\n  endIndex: number\n): boolean => {\n  return cache._sizes.slice(startIndex, endIndex + 1).includes(UNCACHED);\n};\n\nexport const estimateDefaultItemSize = (cache: Writeable<Cache>) => {\n  const measuredSizes = cache._sizes.filter((s) => s !== UNCACHED);\n  // This function will be called after measurement so measured size array must be longer than 0\n  const startItemSize = measuredSizes[0]!;\n\n  cache._defaultItemSize = measuredSizes.every((s) => s === startItemSize)\n    ? // Maybe a fixed size array\n      startItemSize\n    : // Maybe a variable size array\n      median(measuredSizes);\n};\n\nconst appendCache = (\n  cache: Writeable<Cache>,\n  length: number,\n  prepend?: boolean\n) => {\n  const key = prepend ? \"unshift\" : \"push\";\n  for (let i = cache._length; i < length; i++) {\n    cache._sizes[key](UNCACHED);\n    // first offset must be 0\n    cache._offsets.push(i === 0 ? 0 : UNCACHED);\n  }\n  cache._length = length;\n};\n\nexport const initCache = (length: number, itemSize: number): Cache => {\n  const cache: Cache = {\n    _defaultItemSize: itemSize,\n    _length: 0,\n    _measuredOffsetIndex: 0,\n    _sizes: [],\n    _offsets: [],\n  };\n  appendCache(cache as Writeable<Cache>, length);\n  return cache;\n};\n\nexport const updateCacheLength = (\n  cache: Writeable<Cache>,\n  length: number,\n  isShift?: boolean\n): [number, boolean] => {\n  const diff = length - cache._length;\n\n  const isRemove = diff < 0;\n  let shift: number;\n  if (isRemove) {\n    // Removed\n    shift = (\n      isShift ? cache._sizes.splice(0, -diff) : cache._sizes.splice(diff)\n    ).reduce(\n      (acc, removed) =>\n        acc + (removed === UNCACHED ? cache._defaultItemSize : removed),\n      0\n    );\n    cache._offsets.splice(diff);\n  } else {\n    // Added\n    shift = cache._defaultItemSize * diff;\n    appendCache(cache, cache._length + diff, isShift);\n  }\n\n  cache._measuredOffsetIndex = isShift\n    ? // Discard cache for now\n      0\n    : // measuredOffsetIndex shouldn't be less than 0 because it makes scrollSize NaN and cause infinite rerender.\n      // https://github.com/inokawa/virtua/pull/160\n      clamp(length - 1, 0, cache._measuredOffsetIndex);\n  cache._length = length;\n  return [shift, isRemove];\n};\n","import {\n  findStartIndexWithOffset,\n  initCache,\n  getItemSize,\n  computeTotalSize,\n  findIndex as findEndIndex,\n  computeOffset as computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  hasUnmeasuredItemsInRange,\n  estimateDefaultItemSize,\n  updateCacheLength,\n} from \"./cache\";\nimport type { CacheSnapshot, Writeable } from \"./types\";\nimport { abs, clamp, max, min } from \"./utils\";\n\nexport type ScrollJump = Readonly<number>;\nexport type ItemResize = Readonly<[index: number, size: number]>;\ntype ItemsRange = Readonly<[startIndex: number, endIndex: number]>;\n\nconst calculateJump = (\n  cache: Cache,\n  items: readonly ItemResize[],\n  keepEnd?: boolean\n): number => {\n  return items.reduce((acc, [index, size]) => {\n    const diff = size - getItemSize(cache, index);\n    if (!keepEnd || diff > 0) {\n      acc += diff;\n    }\n    return acc;\n  }, 0);\n};\n\n// Scroll offset and sizes can have sub-pixel value if window.devicePixelRatio has decimal value\nconst SUBPIXEL_THRESHOLD = 1.5; // 0.5 * 3\n\nexport const SCROLL_IDLE = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\ntype ScrollDirection =\n  | typeof SCROLL_IDLE\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_VIEWPORT_RESIZE = 2;\nexport const ACTION_ITEMS_LENGTH_CHANGE = 3;\nexport const ACTION_SCROLL = 4;\nexport const ACTION_BEFORE_MANUAL_SCROLL = 5;\nexport const ACTION_SCROLL_END = 6;\nexport const ACTION_MANUAL_SCROLL = 7;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_VIEWPORT_RESIZE, size: number]\n  | [\n      type: typeof ACTION_ITEMS_LENGTH_CHANGE,\n      arg: [length: number, isShift?: boolean | undefined]\n    ]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_BEFORE_MANUAL_SCROLL, offset: number]\n  | [type: typeof ACTION_SCROLL_END, dummy?: void]\n  | [type: typeof ACTION_MANUAL_SCROLL, dummy?: void];\n\ntype Subscriber = () => void;\n\nexport const UPDATE_SCROLL = 0b00001;\nexport const UPDATE_SIZE = 0b00010;\nexport const UPDATE_JUMP = 0b00100;\nexport const UPDATE_IS_SCROLLING = 0b01000;\nexport const UPDATE_SCROLL_WITH_EVENT = 0b10000;\n\nexport type VirtualStore = {\n  _getCache(): CacheSnapshot;\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInTargetViewport(offset: number): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getItemsLength(): number;\n  _getScrollOffset(): number;\n  _getScrollOffsetMax(): number;\n  _getIsScrolling(): boolean;\n  _getViewportSize(): number;\n  _getCorrectedScrollSize(): number;\n  _getJumpCount(): number;\n  _flushJump(): ScrollJump;\n  _subscribe(target: number, cb: Subscriber): () => void;\n  _update(...action: Actions): void;\n};\n\nexport const createVirtualStore = (\n  flushSync: (cb: () => void) => void,\n  elementsCount: number,\n  itemSize: number = 40,\n  initialItemCount: number = 0,\n  cache: Cache = initCache(elementsCount, itemSize),\n  isReverse?: boolean,\n  shouldAutoEstimateItemSize?: boolean\n): VirtualStore => {\n  let viewportSize = itemSize * max(initialItemCount - 1, 0);\n  let scrollOffset = 0;\n  let jumpCount = 0;\n  let jump: ScrollJump = 0;\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\n  let _isShifting = false;\n  let _isManualScrolling = false;\n  let _resized = false;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n\n  const subscribers = new Set<[number, Subscriber]>();\n  const getScrollSize = (): number =>\n    computeTotalSize(cache as Writeable<Cache>);\n  const getScrollOffsetMax = () => getScrollSize() - viewportSize;\n\n  const clampScrollOffset = (value: number): number => {\n    // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\n    return clamp(value, 0, getScrollOffsetMax());\n  };\n  const updateScrollDirection = (dir: ScrollDirection): boolean => {\n    const prev = _scrollDirection;\n    _scrollDirection = dir;\n\n    // Return true if scrolling is just started or stopped\n    return (\n      _scrollDirection !== prev &&\n      (_scrollDirection === SCROLL_IDLE || prev === SCROLL_IDLE)\n    );\n  };\n\n  return {\n    _getCache() {\n      return JSON.parse(JSON.stringify(cache)) as unknown as CacheSnapshot;\n    },\n    _getRange() {\n      const [prevStartIndex, prevEndIndex] = _prevRange;\n      const start = findStartIndexWithOffset(\n        cache as Writeable<Cache>,\n        scrollOffset,\n        // Clamp because prevStartIndex may exceed the limit when children decreased a lot after scrolling\n        min(prevStartIndex, cache._length - 1)\n      );\n      const end = findEndIndex(cache, start, viewportSize);\n      if (prevStartIndex === start && prevEndIndex === end) {\n        return _prevRange;\n      }\n      return (_prevRange = [start, end]);\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInTargetViewport(offset) {\n      const startIndex = findStartIndexWithOffset(\n        cache as Writeable<Cache>,\n        offset,\n        _prevRange[0] // TODO binary search may be better here\n      );\n      return hasUnmeasuredItemsInRange(\n        cache,\n        max(0, startIndex - 1),\n        min(\n          cache._length - 1,\n          findEndIndex(cache, startIndex, viewportSize) + 1\n        )\n      );\n    },\n    _getItemOffset(index) {\n      const offset = computeStartOffset(cache as Writeable<Cache>, index);\n      if (isReverse) {\n        return offset + max(0, viewportSize - getScrollSize());\n      }\n      return offset;\n    },\n    _getItemSize(index) {\n      return getItemSize(cache, index);\n    },\n    _getItemsLength() {\n      return cache._length;\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getScrollOffsetMax: getScrollOffsetMax,\n    _getIsScrolling() {\n      return _scrollDirection !== SCROLL_IDLE;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getCorrectedScrollSize() {\n      return max(getScrollSize(), viewportSize);\n    },\n    _getJumpCount() {\n      return jumpCount;\n    },\n    _flushJump() {\n      const prevJump = jump;\n      jump = 0;\n      return prevJump;\n    },\n    _subscribe(target, cb) {\n      const sub: [number, Subscriber] = [target, cb];\n      subscribers.add(sub);\n      return () => {\n        subscribers.delete(sub);\n      };\n    },\n    _update(type, payload): void {\n      let shouldSync: boolean | undefined;\n      let mutated = 0;\n\n      switch (type) {\n        case ACTION_ITEM_RESIZE: {\n          const updated = payload.filter(\n            ([index, size]) => cache._sizes[index] !== size\n          );\n          // Skip if all items are cached and not updated\n          if (!updated.length) {\n            break;\n          }\n\n          // Calculate jump\n          let diff = 0;\n          if (_isShifting || _isManualScrolling) {\n            // Should maintain visible position under specific situations\n            const [startIndex] = _prevRange;\n\n            if (scrollOffset === 0) {\n              // Do nothing to stick to the start\n            } else if (\n              scrollOffset >\n              getScrollOffsetMax() - SUBPIXEL_THRESHOLD\n            ) {\n              // Keep end to stick to the end\n              diff = calculateJump(cache, updated, true);\n            } else {\n              // Keep start at mid\n              diff = calculateJump(\n                cache,\n                updated.filter(([index]) => index < startIndex)\n              );\n            }\n          } else if (_scrollDirection === SCROLL_UP) {\n            // We can assume jumps occurred on the upper outside during reverse scrolling\n            diff = calculateJump(cache, updated);\n          } else {\n            // Do nothing\n          }\n          if (diff) {\n            jump = diff;\n            jumpCount++;\n            mutated += UPDATE_JUMP;\n          }\n\n          // Update item sizes\n          let isNewItemMeasured = false;\n          updated.forEach(([index, size]) => {\n            if (setItemSize(cache as Writeable<Cache>, index, size)) {\n              isNewItemMeasured = true;\n            }\n          });\n\n          // Estimate initial item size from measured sizes\n          if (\n            shouldAutoEstimateItemSize &&\n            isNewItemMeasured &&\n            // TODO support reverse scroll also\n            !scrollOffset\n          ) {\n            estimateDefaultItemSize(cache as Writeable<Cache>);\n          }\n          mutated += UPDATE_SIZE;\n          _resized = shouldSync = true;\n          break;\n        }\n        case ACTION_VIEWPORT_RESIZE: {\n          if (viewportSize !== payload) {\n            viewportSize = payload;\n            mutated = UPDATE_SIZE;\n          }\n          break;\n        }\n        case ACTION_ITEMS_LENGTH_CHANGE: {\n          if (payload[1]) {\n            // Calc distance before updating cache\n            const distanceToEnd = getScrollOffsetMax() - scrollOffset;\n\n            const [shift, isRemove] = updateCacheLength(\n              cache as Writeable<Cache>,\n              payload[0],\n              true\n            );\n            const diff = isRemove ? -min(shift, distanceToEnd) : shift;\n            jump += diff;\n            scrollOffset = clampScrollOffset(scrollOffset + diff);\n            jumpCount++;\n\n            mutated = UPDATE_SCROLL + UPDATE_JUMP;\n            _isShifting = true;\n          } else {\n            updateCacheLength(cache as Writeable<Cache>, payload[0]);\n          }\n          break;\n        }\n        case ACTION_SCROLL:\n        case ACTION_BEFORE_MANUAL_SCROLL: {\n          // Skip if offset is not changed\n          if (scrollOffset === payload) {\n            break;\n          }\n\n          if (type === ACTION_SCROLL) {\n            const delta = payload - scrollOffset;\n            // Scrolling after resizing will be caused by jump compensation\n            const isJustResized = _resized;\n            _resized = false;\n\n            // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n            // Scroll events are dispatched enough so it's ok to skip some of them.\n            if (\n              (_scrollDirection === SCROLL_IDLE || !isJustResized) &&\n              // Ignore until manual scrolling\n              !_isManualScrolling\n            ) {\n              if (updateScrollDirection(delta < 0 ? SCROLL_UP : SCROLL_DOWN)) {\n                mutated += UPDATE_IS_SCROLLING;\n              }\n            }\n\n            // Ignore manual scroll because it may be called in useEffect/useLayoutEffect and cause the warn below.\n            // Warning: flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\n            //\n            // Update synchronously if scrolled a lot\n            shouldSync = abs(delta) > viewportSize;\n\n            mutated += UPDATE_SCROLL_WITH_EVENT;\n\n            if (!isJustResized) {\n              _isShifting = false;\n            }\n          }\n\n          scrollOffset = clampScrollOffset(payload);\n          mutated += UPDATE_SCROLL;\n          break;\n        }\n        case ACTION_SCROLL_END: {\n          if (updateScrollDirection(SCROLL_IDLE)) {\n            mutated = UPDATE_IS_SCROLLING;\n          }\n          _isShifting = _isManualScrolling = false;\n          break;\n        }\n        case ACTION_MANUAL_SCROLL: {\n          _isManualScrolling = true;\n          break;\n        }\n      }\n\n      if (mutated) {\n        const update = () => {\n          subscribers.forEach(([target, cb]) => {\n            // Early return to skip React's computation\n            if (!(mutated & target)) {\n              return;\n            }\n            cb();\n          });\n        };\n        if (shouldSync) {\n          // https://github.com/facebook/react/issues/25191\n          // https://github.com/facebook/react/blob/a5fc797db14c6e05d4d5c4dbb22a0dd70d41f5d5/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1443-L1447\n          flushSync(update);\n        } else {\n          update();\n        }\n      }\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { ReactElement, ReactFragment, ReactNode } from \"react\";\nimport { exists } from \"../core/utils\";\n\nexport const refKey = \"current\";\n\nexport const emptyComponents = {};\n\ntype ItemElement = ReactElement | ReactFragment | string | number;\n\nconst forEach = (children: ReactNode, elements: ItemElement[]) => {\n  if (Array.isArray(children)) {\n    for (const c of children) {\n      forEach(c, elements);\n    }\n  } else if (!exists(children) || typeof children === \"boolean\") {\n    // filter out, that is the same as React.Children.toArray\n  } else {\n    elements.push(children);\n  }\n};\n\n// Replace React.Children.forEach with our tiny implementation.\n// In our usage, just flatten children array keeping element instances and their keys, React.Children is redundant and slow.\n//\n// - React.Children.toArray is slow because it clones element instance.\n// - React.Children.map is slow because it clones element instance.\n// - React.Children.forEach is slow because it escapes and modifies keys even if they are unused.\n//\n// And React.Children seems to be in maintenance mode so it's unlikely it would be improved and ported to older versions.\n// https://github.com/reactjs/rfcs/pull/61#issuecomment-584402735\nexport const flattenChildren = (children: ReactNode): ItemElement[] => {\n  const elements: ItemElement[] = [];\n  forEach(children, elements);\n  return elements;\n};\n\nexport type MayHaveKey = { key?: React.Key };\n","import { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { refKey } from \"./utils\";\n\nexport const useLatestRef = <T>(value: T) => {\n  const ref = useRef<T>(value);\n\n  useIsomorphicLayoutEffect(() => {\n    ref[refKey] = value;\n  }, [value]);\n\n  return ref;\n};\n","import { useState } from \"react\";\nimport { useLatestRef } from \"./useLatestRef\";\nimport { refKey } from \"./utils\";\nimport { VirtualStore } from \"../core/store\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\nexport const useSelector = <T>(\n  store: VirtualStore,\n  getSnapShot: () => T,\n  target: number,\n  shouldGetLatest?: boolean\n): T => {\n  const [state, setState] = useState(getSnapShot);\n  const getter = useLatestRef(getSnapShot);\n\n  useIsomorphicLayoutEffect(() => {\n    return store._subscribe(target, () => {\n      setState(() => getter[refKey]());\n    });\n  }, []);\n\n  // especially for sort of items\n  if (shouldGetLatest) {\n    const snap = getSnapShot();\n    if (state !== snap) {\n      setState(snap);\n    }\n  }\n  return state;\n};\n","import { once } from \"./utils\";\n\n// The scroll position may be negative value in rtl direction.\n//\n// left  right result\n// -100  0     true    spec compliant\n// 0     100   false   probably Chrome earlier than v85\n// https://github.com/othree/jquery.rtl-scroll-type\nexport const hasNegativeOffsetInRtl = /*#__PURE__*/ once(\n  (scrollable: HTMLElement) => {\n    const key = \"scrollLeft\";\n    const prev = scrollable[key];\n    scrollable[key] = 1;\n    // scrollLeft can be positive under some specific situations even if negative mode, so we use `<` for now.\n    const isNegative = scrollable[key] < 1;\n    scrollable[key] = prev;\n    return isNegative;\n  }\n);\n","import { hasNegativeOffsetInRtl } from \"./environment\";\nimport {\n  ACTION_SCROLL,\n  ACTION_BEFORE_MANUAL_SCROLL,\n  ScrollJump,\n  VirtualStore,\n  ACTION_SCROLL_END,\n  UPDATE_SIZE,\n  ACTION_MANUAL_SCROLL,\n} from \"./store\";\nimport { ScrollToIndexAlign } from \"./types\";\nimport { debounce, throttle, timeout, clamp } from \"./utils\";\n\n// Infer scroll state also from wheel events\n// Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\nconst createOnWheel = (\n  store: VirtualStore,\n  isHorizontal: boolean,\n  onScrollStopped: () => void\n) => {\n  return throttle((e: WheelEvent) => {\n    if (!store._getIsScrolling()) {\n      // Scroll start should be detected with scroll event\n      return;\n    }\n    if (e.ctrlKey) {\n      // Probably a pinch-to-zoom gesture\n      return;\n    }\n    // Get delta before checking deltaMode for firefox behavior\n    // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n    if (isHorizontal ? e.deltaX : e.deltaY) {\n      const offset = store._getScrollOffset();\n      if (offset > 0 && offset < store._getScrollOffsetMax()) {\n        onScrollStopped();\n      }\n    }\n  }, 50);\n};\n\nexport type Scroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _scrollTo: (offset: number) => void;\n  _scrollBy: (offset: number) => void;\n  _scrollToIndex: (index: number, align?: ScrollToIndexAlign) => void;\n  _fixScrollJump: (jump: ScrollJump) => void;\n};\n\nexport const createScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean,\n  isRtl: boolean\n): Scroller => {\n  let rootElement: HTMLElement | undefined;\n  let scrollToQueue: [() => void, () => void] | undefined;\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n\n  const normalizeOffset = (offset: number, diff?: boolean): number => {\n    if (isHorizontal && isRtl) {\n      if (hasNegativeOffsetInRtl(rootElement!)) {\n        return -offset;\n      } else {\n        return diff ? -offset : store._getScrollOffsetMax() - offset;\n      }\n    }\n    return offset;\n  };\n\n  const scrollManually = async (getOffset: () => number) => {\n    if (!rootElement) return;\n\n    const getTargetOffset = (): number => {\n      // Adjust if the offset is over the end, to get correct startIndex.\n      return clamp(getOffset(), 0, store._getScrollOffsetMax());\n    };\n\n    while (true) {\n      // Sync viewport to scroll destination\n      // In order to scroll to the correct position, mount the items and measure their sizes before scrolling.\n      const targetOffset = getTargetOffset();\n      store._update(ACTION_BEFORE_MANUAL_SCROLL, targetOffset);\n\n      if (!store._hasUnmeasuredItemsInTargetViewport(targetOffset)) {\n        break;\n      }\n\n      if (scrollToQueue) {\n        // Cancel waiting scrollTo\n        scrollToQueue[1]();\n      }\n\n      // Wait for the scroll destination items to be measured.\n      const unsubscribe = store._subscribe(UPDATE_SIZE, () => {\n        scrollToQueue && scrollToQueue[0]();\n      });\n      try {\n        // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n        // For example, ResizeObserver may not fire when window is not visible.\n        await new Promise<void>((resolve, reject) => {\n          let resolved = false;\n\n          const resolveQueue = () => {\n            if (resolved) return;\n            resolved = true;\n            resolve();\n            scrollToQueue = undefined;\n          };\n          scrollToQueue = [resolveQueue, reject];\n\n          // In some specific situation with VGrid, the promise never resolved so we resolve it if timed out.\n          timeout(resolveQueue, 250);\n        });\n      } catch (e) {\n        // canceled\n        return;\n      } finally {\n        unsubscribe();\n      }\n    }\n\n    // Scroll with the updated value\n    rootElement[scrollToKey] = normalizeOffset(getTargetOffset());\n    store._update(ACTION_MANUAL_SCROLL);\n  };\n\n  return {\n    _initRoot(root) {\n      rootElement = root;\n\n      const syncViewportToScrollPosition = () => {\n        store._update(ACTION_SCROLL, normalizeOffset(root[scrollToKey]));\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._update(ACTION_SCROLL_END);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      const onWheel = createOnWheel(store, isHorizontal, onScrollStopped);\n\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _scrollTo(offset) {\n      scrollManually(() => offset);\n    },\n    _scrollBy(offset) {\n      offset += store._getScrollOffset();\n      scrollManually(() => offset);\n    },\n    _scrollToIndex(index, align) {\n      index = clamp(index, 0, store._getItemsLength() - 1);\n\n      scrollManually(\n        align === \"end\"\n          ? () =>\n              store._getItemOffset(index) +\n              store._getItemSize(index) -\n              store._getViewportSize()\n          : () => store._getItemOffset(index)\n      );\n    },\n    _fixScrollJump: (jump) => {\n      if (!rootElement) return;\n      rootElement[scrollToKey] += normalizeOffset(jump, true);\n    },\n  };\n};\n\nexport type WindowScroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _fixScrollJump: (jump: ScrollJump) => void;\n};\n\nexport const createWindowScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowScroller => {\n  const scrollToKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n  const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n\n  return {\n    _initRoot(rootElement) {\n      let visible = false;\n\n      const getOffsetToWindow = (node: HTMLElement, offset: number): number => {\n        const nodeOffset = offset + node[offsetKey];\n\n        const parent = node.offsetParent;\n        if (node === document.body || !parent) {\n          return nodeOffset;\n        }\n\n        return getOffsetToWindow(parent as HTMLElement, nodeOffset);\n      };\n\n      const syncViewportToScrollPosition = () => {\n        if (!visible) return;\n        store._update(\n          ACTION_SCROLL,\n          window[scrollToKey] - getOffsetToWindow(rootElement, 0)\n        );\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._update(ACTION_SCROLL_END);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      const onWheel = createOnWheel(store, isHorizontal, onScrollStopped);\n\n      const io = new IntersectionObserver(([entry]) => {\n        visible = entry!.isIntersecting;\n      });\n      io.observe(rootElement);\n\n      window.addEventListener(\"scroll\", onScroll);\n      window.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        io.disconnect();\n        window.removeEventListener(\"scroll\", onScroll);\n        window.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _fixScrollJump: (jump) => {\n      // TODO support case two window scrollers exist in the same view\n      window.scrollBy(isHorizontal ? jump : 0, isHorizontal ? 0 : jump);\n    },\n  };\n};\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import {\n  ACTION_ITEM_RESIZE,\n  ACTION_VIEWPORT_RESIZE,\n  ItemResize,\n  VirtualStore,\n} from \"./store\";\nimport { exists, computeStyle, getStyleNumber, max, once } from \"./utils\";\n\nconst rootObserveOpts: ResizeObserverOptions = { box: \"border-box\" };\n\nexport interface ListResizer {\n  _observeRoot(root: HTMLElement): () => void;\n  _observeItem(el: HTMLElement, i: number): () => void;\n}\n\nexport const createResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  let rootElement: HTMLElement | undefined;\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const e of entries) {\n        const { target, contentRect } = e;\n        if (target === rootElement) {\n          store._update(\n            ACTION_VIEWPORT_RESIZE,\n            contentRect[sizeKey] +\n              contentRect[isHorizontal ? \"left\" : \"top\"] +\n              // contentRect doesn't have paddingRight/paddingBottom so get them from computed style\n              // https://www.w3.org/TR/resize-observer/#css-definitions\n              getStyleNumber(\n                computeStyle(rootElement)[\n                  isHorizontal ? \"paddingRight\" : \"paddingBottom\"\n                ]\n              )\n          );\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root, rootObserveOpts);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport const createWindowResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        const index = mountedIndexes.get(target);\n        if (exists(index)) {\n          resizes.push([index, contentRect[sizeKey]]);\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot() {\n      const cb = () => {\n        store._update(ACTION_VIEWPORT_RESIZE, window[windowSizeKey]);\n      };\n      window.addEventListener(\"resize\", cb);\n      cb();\n      return () => {\n        window.removeEventListener(\"resize\", cb);\n        getResizeObserver().disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let rootElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizedRows = new Set<number>();\n      const resizedCols = new Set<number>();\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          // contentRect doesn't have paddingRight/paddingBottom so get them from computed style\n          // https://www.w3.org/TR/resize-observer/#css-definitions\n          // TODO subtract scroll bar width/height\n          // https://github.com/w3c/csswg-drafts/issues/3536\n          const style = computeStyle(rootElement);\n          vStore._update(\n            ACTION_VIEWPORT_RESIZE,\n            contentRect[heightKey] +\n              contentRect.top +\n              getStyleNumber(style.paddingBottom)\n          );\n          hStore._update(\n            ACTION_VIEWPORT_RESIZE,\n            contentRect[widthKey] +\n              contentRect.left +\n              getStyleNumber(style.paddingRight)\n          );\n        } else {\n          const cell = mountedIndexes.get(target);\n          if (cell) {\n            const [rowIndex, colIndex] = cell;\n            const key = getKey(rowIndex, colIndex);\n            const prevSize = sizeCache.get(key);\n            const size: CellSize = [\n              contentRect[heightKey],\n              contentRect[widthKey],\n            ];\n            let rowResized: boolean | undefined;\n            let colResized: boolean | undefined;\n            if (!prevSize) {\n              rowResized = colResized = true;\n            } else {\n              if (prevSize[0] !== size[0]) {\n                rowResized = true;\n              }\n              if (prevSize[1] !== size[1]) {\n                colResized = true;\n              }\n            }\n            if (rowResized) {\n              resizedRows.add(rowIndex);\n            }\n            if (colResized) {\n              resizedCols.add(colIndex);\n            }\n            if (rowResized || colResized) {\n              sizeCache.set(key, size);\n            }\n          }\n        }\n      }\n\n      if (resizedRows.size) {\n        const heightResizes: ItemResize[] = [];\n        resizedRows.forEach((rowIndex) => {\n          let maxHeight = 0;\n          maybeCachedColIndexes.forEach((colIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxHeight = max(maxHeight, size[0]);\n            }\n          });\n          if (maxHeight) {\n            heightResizes.push([rowIndex, maxHeight]);\n          }\n        });\n        vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n      }\n      if (resizedCols.size) {\n        const widthResizes: ItemResize[] = [];\n        resizedCols.forEach((colIndex) => {\n          let maxWidth = 0;\n          maybeCachedRowIndexes.forEach((rowIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxWidth = max(maxWidth, size[1]);\n            }\n          });\n          if (maxWidth) {\n            widthResizes.push([colIndex, maxWidth]);\n          }\n        });\n        hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root, rootObserveOpts);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n  };\n};\n\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","import {\n  CSSProperties,\n  ReactElement,\n  ReactNode,\n  forwardRef,\n  useMemo,\n} from \"react\";\n\nexport type ViewportComponentAttributes = Pick<\n  React.HTMLAttributes<HTMLElement>,\n  \"className\" | \"style\" | \"id\" | \"role\" | \"tabIndex\"\n> &\n  React.AriaAttributes;\n\n/**\n * Props of customized scrollable component.\n */\nexport interface CustomViewportComponentProps {\n  /**\n   * Renderable item elements.\n   */\n  children: ReactNode;\n  /**\n   * Attributes that should be passed to the scrollable element.\n   */\n  attrs: ViewportComponentAttributes;\n  /**\n   * Total height of items. It's undefined if component is not vertically scrollable.\n   */\n  height: number | undefined;\n  /**\n   * Total width of items. It's undefined if component is not horizontally scrollable.\n   */\n  width: number | undefined;\n  /**\n   * Currently component is scrolling or not.\n   */\n  scrolling: boolean;\n}\n\nexport const Viewport = forwardRef<any, CustomViewportComponentProps>(\n  ({ children, attrs, width, height, scrolling }, ref): ReactElement => {\n    return (\n      <div ref={ref} {...attrs}>\n        <div\n          style={useMemo((): CSSProperties => {\n            return {\n              position: \"relative\",\n              visibility: \"hidden\",\n              width: width ?? \"100%\",\n              height: height ?? \"100%\",\n              pointerEvents: scrolling ? \"none\" : \"auto\",\n            };\n          }, [width, height, scrolling])}\n        >\n          {children}\n        </div>\n      </div>\n    );\n  }\n);\n\nexport type CustomViewportComponent = typeof Viewport;\n"],"names":["min","max","abs","now","values","timeout","clamp","value","minValue","maxValue","exists","v","median","arr","s","a","b","mid","debounce","fn","ms","id","cancel","debouncedFn","throttle","time","args","once","called","cache","computeStyle","getStyleNumber","UNCACHED","getItemSize","index","size","setItemSize","isInitialMeasurement","computeOffset","i","top","computeTotalSize","findIndex","distance","sum","h","findStartIndexWithOffset","offset","initialIndex","hasUnmeasuredItemsInRange","startIndex","endIndex","estimateDefaultItemSize","measuredSizes","startItemSize","appendCache","length","prepend","key","initCache","itemSize","updateCacheLength","isShift","diff","isRemove","shift","acc","removed","calculateJump","items","keepEnd","SUBPIXEL_THRESHOLD","SCROLL_IDLE","SCROLL_DOWN","SCROLL_UP","ACTION_ITEM_RESIZE","ACTION_VIEWPORT_RESIZE","ACTION_ITEMS_LENGTH_CHANGE","ACTION_SCROLL","ACTION_BEFORE_MANUAL_SCROLL","ACTION_SCROLL_END","ACTION_MANUAL_SCROLL","UPDATE_SCROLL","UPDATE_SIZE","UPDATE_JUMP","UPDATE_IS_SCROLLING","UPDATE_SCROLL_WITH_EVENT","createVirtualStore","flushSync","elementsCount","initialItemCount","isReverse","shouldAutoEstimateItemSize","viewportSize","scrollOffset","jumpCount","jump","_scrollDirection","_isShifting","_isManualScrolling","_resized","_prevRange","subscribers","getScrollSize","getScrollOffsetMax","clampScrollOffset","updateScrollDirection","dir","prev","prevStartIndex","prevEndIndex","start","end","findEndIndex","computeStartOffset","prevJump","target","cb","sub","type","payload","shouldSync","mutated","updated","isNewItemMeasured","distanceToEnd","delta","isJustResized","update","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","refKey","emptyComponents","forEach","children","elements","c","flattenChildren","useLatestRef","ref","useRef","useSelector","store","getSnapShot","shouldGetLatest","state","setState","useState","getter","snap","hasNegativeOffsetInRtl","scrollable","isNegative","createOnWheel","isHorizontal","onScrollStopped","e","createScroller","isRtl","rootElement","scrollToQueue","scrollToKey","normalizeOffset","scrollManually","getOffset","getTargetOffset","targetOffset","unsubscribe","resolve","reject","resolved","resolveQueue","root","syncViewportToScrollPosition","onScroll","onWheel","align","createWindowScroller","offsetKey","visible","getOffsetToWindow","node","nodeOffset","parent","io","entry","useStatic","init","rootObserveOpts","createResizer","sizeKey","mountedIndexes","getResizeObserver","entries","resizes","contentRect","ro","el","createWindowResizer","windowSizeKey","createGridResizer","vStore","hStore","heightKey","widthKey","maybeCachedRowIndexes","maybeCachedColIndexes","sizeCache","getKey","rowIndex","colIndex","resizedRows","resizedCols","style","cell","prevSize","rowResized","colResized","heightResizes","maxHeight","widthResizes","maxWidth","Viewport","forwardRef","attrs","width","height","scrolling","jsx","useMemo"],"mappings":"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"}