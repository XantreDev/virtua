import{a as w}from"./jsx-runtime-e162df28.js";import{r as n}from"./index-5284b0bf.js";import{u as g,a as V,r as p,i as D,b as L,c as J,e as K,D as U,d as Y,f as B,g as F,m as G,h as Q}from"./DefaultWindow-bbaf3b04.js";const X=n.memo(({_children:a,_resizer:c,_store:l,_index:s,_element:h,_isHorizontal:o,_isRtl:u})=>{const d=n.useRef(null),v=g(l,()=>l._getItemOffset(s),!0),y=g(l,()=>l._isUnmeasuredItem(s),!0);return V(()=>c._observeItem(d[p],s),[s]),w(h,{ref:d,style:n.useMemo(()=>{const _=u?"right":"left",b={margin:0,padding:0,position:"absolute",[o?"height":"width"]:"100%",[o?"top":_]:0,[o?_:"top"]:v,visibility:y?"hidden":"visible"};return o&&(b.display="flex"),b},[v,y]),children:a})}),Z=({_children:a,_ref:c,_store:l,_element:s,_scrolling:h,_attrs:o,_isHorizontal:u})=>{const d=g(l,l._getScrollSize);return w(s,{ref:c,width:u?d:void 0,height:u?void 0:d,scrolling:h,attrs:n.useMemo(()=>({...o,style:{overflow:u?"auto hidden":"hidden auto",contain:"strict",width:"100%",height:"100%",padding:0,margin:0,...o.style}}),[o]),children:a})},M=n.forwardRef(({children:a,overscan:c=4,initialItemSize:l,initialItemCount:s,horizontal:h,mode:o,element:u=U,itemElement:d="div",onScroll:v,onScrollStop:y,onRangeChange:_,...b},O)=>{const C=n.useMemo(()=>{const e=[];return n.Children.forEach(a,t=>{D(t)||e.push(t)}),e},[a]),m=C.length,R=L(v),k=L(y),[j,H]=n.useState(!1),[r,x,f,E,P]=J(()=>{const e=!!h,t=o==="rtl",i=Y(m,l,s,o==="reverse",S=>{H(S),S||k[p]&&k[p]()},S=>{R[p]&&R[p](S)});return[i,B(i,e),F(i,e,t),e,t]});r._updateCacheLength(m);const[I,z]=g(r,r._getRange),N=g(r,r._getJumpCount),q=n.useRef(null);V(()=>{const e=q[p],t=x._observeRoot(e),i=f._initRoot(e);return()=>{t(),i()}},[]),V(()=>{const e=r._flushJump();e&&f._fixScrollJump(e)},[N]),n.useEffect(()=>{_&&_({start:I,end:z,count:m})},[I,z]),n.useImperativeHandle(O,()=>({get scrollOffset(){return r._getScrollOffset()},get scrollSize(){return f._getActualScrollSize()},get viewportSize(){return r._getViewportSize()},scrollToIndex(e){f._scrollToIndex(e,m)},scrollTo:f._scrollTo,scrollBy(e){f._scrollTo(r._getScrollOffset()+e)}}),[m]);const T=G(I-c,0),W=Q(z+c,m-1),A=n.useMemo(()=>{const e=[];for(let t=T;t<=W;t++){const i=C[t];K(i)&&e.push(w(X,{_resizer:x,_store:r,_index:t,_element:d,_children:i,_isHorizontal:E,_isRtl:P},(i==null?void 0:i.key)||t))}return e},[C,T,W]);return w(Z,{_ref:q,_store:r,_element:u,_scrolling:j,_children:A,_attrs:b,_isHorizontal:E})});try{M.displayName="VList",M.__docgenInfo={description:"Virtualized list component. See {@link VListProps} and {@link VListHandle}.",displayName:"VList",props:{children:{defaultValue:null,description:"Elements rendered by this component.",name:"children",required:!0,type:{name:"ReactNode"}},overscan:{defaultValue:{value:"4"},description:`Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.
@defaultValue 4`,name:"overscan",required:!1,type:{name:"number"}},initialItemSize:{defaultValue:null,description:`Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.

- If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.
- If set, you can opt out estimation and use the value as initial item size.`,name:"initialItemSize",required:!1,type:{name:"number"}},initialItemCount:{defaultValue:null,description:"If set, the specified amount of items will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.",name:"initialItemCount",required:!1,type:{name:"number"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean"}},mode:{defaultValue:null,description:"Scroll modes that should be set in certain situations.\n\n- `reverse`: This mode will Adjust some styles to be suitable for bottom-to-top scrolling.\n- `rtl`: You have to set this mode if you use this component under `direction: rtl` style.",name:"mode",required:!1,type:{name:"enum",value:[{value:'"reverse"'},{value:'"rtl"'}]}},element:{defaultValue:{value:`forwardRef<any, CustomWindowComponentProps>(
  ({ children, attrs, width, height, scrolling }, ref): ReactElement => {
    return (
      <div ref={ref} {...attrs}>
        <div
          style={useMemo((): CSSProperties => {
            return {
              position: "relative",
              visibility: "hidden",
              width: width ?? "100%",
              height: height ?? "100%",
              pointerEvents: scrolling ? "none" : "auto",
            };
          }, [width, height, scrolling])}
        >
          {children}
        </div>
      </div>
    );
  }
)`},description:`Customized element type for scrollable element. This element will get {@link CustomWindowComponentProps} as props.
@defaultValue {@link DefaultWindow }`,name:"element",required:!1,type:{name:"ForwardRefExoticComponent<CustomWindowComponentProps & RefAttributes<any>>"}},itemElement:{defaultValue:{value:"div"},description:`Customized element type for item element. This element will get {@link CustomItemComponentProps} as props.
@defaultValue "div"`,name:"itemElement",required:!1,type:{name:"CustomItemComponentOrElement"}},onScroll:{defaultValue:null,description:`Callback invoked whenever scroll offset changes.
@param offset Current scrollTop or scrollLeft.`,name:"onScroll",required:!1,type:{name:"(offset: number) => void"}},onScrollStop:{defaultValue:null,description:"Callback invoked when scrolling stops.",name:"onScrollStop",required:!1,type:{name:"() => void"}},onRangeChange:{defaultValue:null,description:"Callback invoked when visible items range changes.",name:"onRangeChange",required:!1,type:{name:"(payload: { start: number; end: number; count: number; }) => void"}}}}}catch{}export{M as V};
//# sourceMappingURL=VList-1ae0920c.js.map
