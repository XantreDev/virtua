!function(){function e(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function n(n){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?e(Object(i),!0).forEach((function(e){t(n,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(i)):e(Object(i)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(i,e))}))}return n}function t(e,n,t){return(n=function(e){var n=function(e,n){if("object"!=typeof e||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var r=t.call(e,n||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===n?String:Number)(e)}(e,"string");return"symbol"==typeof n?n:String(n)}(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}System.register(["./jsx-runtime-legacy-fe2b3564.js","./index-legacy-612e7deb.js","./index-legacy-2962aa71.js","./VList-legacy-d9cac1c9.js","./resizer-legacy-ffe6a524.js","./index-legacy-360d6611.js"],(function(e,t){"use strict";var r,i,o,a,s,c;return{setters:[e=>{r=e.a,i=e.j,o=e.F},e=>{a=e.r},e=>{s=e.y},e=>{c=e.V},null,null],execute:function(){var t,l,d;e("default",{component:c});const u=e=>r(o,{children:[i("div",{style:{height:100,display:e.hidden?"none":"flex",alignItems:"center",justifyContent:"center",background:"white"},children:i("span",{className:"loader"})}),i("style",{children:'\n      .loader {\n        width: 48px;\n        height: 48px;\n        border-radius: 50%;\n        position: relative;\n        animation: rotate 1s linear infinite\n      }\n      .loader::before {\n        content: "";\n        box-sizing: border-box;\n        position: absolute;\n        inset: 0px;\n        border-radius: 50%;\n        border: 5px solid #ccc;\n        animation: prixClipFix 2s linear infinite ;\n      }\n  \n      @keyframes rotate {\n        100%   {transform: rotate(360deg)}\n      }\n  \n      @keyframes prixClipFix {\n          0%   {clip-path:polygon(50% 50%,0 0,0 0,0 0,0 0,0 0)}\n          25%  {clip-path:polygon(50% 50%,0 0,100% 0,100% 0,100% 0,100% 0)}\n          50%  {clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,100% 100%,100% 100%)}\n          75%  {clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 100%)}\n          100% {clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 0)}\n      }'})]}),m={borderBottom:"solid 1px #ccc",background:"white",display:"flex",flexDirection:"row",padding:10},p={width:200,minWidth:200},f=({name:e,text:n})=>r("div",{style:m,children:[i("div",{style:p,children:e}),i("div",{children:n})]}),g=e("InfiniteScrolling",{render:()=>{const e=a.useRef(0),n=()=>Array.from({length:50},(()=>({id:String(e.current++),name:`${s.name.firstName()} ${s.name.lastName()}`,text:s.lorem.paragraphs(4)}))),[t,o]=a.useState(n),[l,d]=a.useState(!1),[m,p]=a.useState([-1,-1]),g=a.useRef(-1);return r("div",{style:{height:"100vh",display:"flex",flexDirection:"column"},children:[r("div",{style:{background:"white",borderBottom:"solid 1px #ccc"},children:["items: ",t.length," index: (",m[0],", ",m[1],")"]}),r(c,{style:{flex:1},itemSize:200,onRangeChange:async({start:e,end:t,count:r})=>{a.startTransition((()=>{p([e,t])})),t+30>r&&g.current<r&&(g.current=r,d(!0),await new Promise((e=>setTimeout(e,1500))),o((e=>[...e,...n()])),d(!1))},children:[t.map((e=>i(f,{id:e.id,name:e.name,text:e.text},e.id))),i(u,{hidden:!l})]})]})}});g.parameters=n(n({},g.parameters),{},{docs:n(n({},null===(t=g.parameters)||void 0===t?void 0:t.docs),{},{source:n({originalSource:'{\n  render: () => {\n    const id = useRef(0);\n    const createItem = (): Data => ({\n      id: String(id.current++),\n      name: `${faker.name.firstName()} ${faker.name.lastName()}`,\n      text: faker.lorem.paragraphs(4)\n    });\n    const ITEM_BATCH_COUNT = 50;\n    const createItems = () => Array.from({\n      length: ITEM_BATCH_COUNT\n    }, () => createItem());\n    const [items, setItems] = useState(createItems);\n    const [fetching, setFetching] = useState(false);\n    const [range, setRange] = useState([-1, -1]);\n    const fetchedCountRef = useRef(-1);\n    return <div style={{\n      height: "100vh",\n      display: "flex",\n      flexDirection: "column"\n    }}>\n        <div style={{\n        background: "white",\n        borderBottom: "solid 1px #ccc"\n      }}>\n          items: {items.length} index: ({range[0]}, {range[1]})\n        </div>\n        <VList style={{\n        flex: 1\n      }} itemSize={200} onRangeChange={async ({\n        start,\n        end,\n        count\n      }) => {\n        startTransition(() => {\n          setRange([start, end]);\n        });\n        if (end + 30 > count && fetchedCountRef.current < count) {\n          fetchedCountRef.current = count;\n          setFetching(true);\n          await new Promise(r => setTimeout(r, 1500));\n          setItems(prev => [...prev, ...createItems()]);\n          setFetching(false);\n        }\n      }}>\n          {items.map(d => <Row key={d.id} id={d.id} name={d.name} text={d.text} />)}\n          {/* Now hide spinner without unmounting because onRangeChange is called twice due to item length change */}\n          <Spinner hidden={!fetching} />\n        </VList>\n      </div>;\n  }\n}'},null===(l=g.parameters)||void 0===l||null===(d=l.docs)||void 0===d?void 0:d.source)})});e("__namedExportsOrder",["InfiniteScrolling"])}}}))}();
//# sourceMappingURL=InfiniteScrolling.stories-legacy-dfd65246.js.map
