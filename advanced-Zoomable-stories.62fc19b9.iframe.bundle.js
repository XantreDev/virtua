/*! For license information please see advanced-Zoomable-stories.62fc19b9.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkvirtua=self.webpackChunkvirtua||[]).push([[750],{"./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{var e=__webpack_require__("./node_modules/react/index.js");var k="function"==typeof Object.is?Object.is:function h(a,b){return a===b&&(0!==a||1/a==1/b)||a!=a&&b!=b},l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}var u="undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?function t(a,b){return b()}:function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];return n((function(){c.value=d,c.getSnapshot=b,r(c)&&g({inst:c})}),[a,d,b]),m((function(){return r(c)&&g({inst:c}),a((function(){r(c)&&g({inst:c})}))}),[a]),p(d),d};exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u},"./node_modules/use-sync-external-store/shim/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js")},"./src/List.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{a:()=>List});var jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js"),react=__webpack_require__("./node_modules/react/index.js");const min=Math.min,max=Math.max,range=(Math.abs,(length,cb)=>Array.from({length},((_,i)=>cb(i)))),getItemSize=(cache,index)=>{const size=cache._sizes[index];return-1===size?cache._defaultItemSize:size},findIndex=(cache,i,distance)=>{let sum=0;if(distance>=0)for(;i<cache._length-1;){const h=getItemSize(cache,i);if(sum+=h,i++,sum>=distance){sum-h/2>=distance&&i--;break}}else for(;i>0;){i--;const h=getItemSize(cache,i);if(sum-=h,sum<=distance){sum+h/2<distance&&i++;break}}return min(max(i,0),cache._length-1)},findEndIndex=findIndex,computeStartOffset=(cache,index)=>{if(!cache._length)return 0;if(cache._measuredOffsetIndex>=index)return cache._offsets[index];let top=cache._offsets[cache._measuredOffsetIndex];for(let i=cache._measuredOffsetIndex;i<=index&&(cache._offsets[i]=top,i!==index);i++)top+=getItemSize(cache,i);return cache._measuredOffsetIndex=index,top},resetCache=(length,itemSize,cache)=>{var _a;return{_defaultItemSize:itemSize,_length:length,_measuredOffsetIndex:null!=(_a=cache&&min(cache._measuredOffsetIndex,length-1))?_a:0,_sizes:range(length,(i=>{var _a2;return null!=(_a2=cache&&cache._sizes[i])?_a2:-1})),_offsets:range(length,(i=>{var _a2;return 0===i?0:null!=(_a2=cache&&cache._offsets[i])?_a2:-1}))}},mutate=(state,action,itemSize)=>{switch(action._type){case 0:return state._cache._length!==action._length&&(state._cache=resetCache(action._length,itemSize,state._cache),!0);case 1:{const updated=action._entries.filter((([index,size])=>state._cache._sizes[index]!==size));if(!updated.length)return!1;const jump=[];return updated.forEach((([index,size])=>{jump.push([index,size-getItemSize(state._cache,index)]),((cache,index,size)=>{cache._sizes[index]=size,cache._measuredOffsetIndex=min(index,cache._measuredOffsetIndex)})(state._cache,index,size)})),state._jump=jump,!0}case 2:return(state._viewportWidth!==action._width||state._viewportHeight!==action._height)&&(state._viewportWidth=action._width,state._viewportHeight=action._height,!0);case 3:{const prevStartIndex=state._startIndex,prevOffset=computeStartOffset(state._cache,prevStartIndex);return prevOffset!==action._offset&&(state._startIndex=((cache,offset,prevStartIndex,prevOffset)=>findIndex(cache,prevStartIndex,offset-prevOffset))(state._cache,action._offset,prevStartIndex,prevOffset))!==prevStartIndex}}},useVirtualStore=(itemCount,itemSize,isHorizontal)=>{const ref=(0,react.useRef)();return ref.current||(ref.current=(()=>{const subscribers=new Set,state={_startIndex:0,_viewportWidth:0,_viewportHeight:0,_cache:resetCache(itemCount,itemSize),_jump:[]},getViewportSize=()=>isHorizontal?state._viewportWidth:state._viewportHeight;let scrollToQueue;return{_getStartIndex:()=>state._startIndex,_getEndIndex:()=>findEndIndex(state._cache,state._startIndex,getViewportSize()),_isUnmeasuredItem:index=>-1===state._cache._sizes[index],_hasUnmeasuredItemsInRange:startIndex=>((cache,startIndex,endIndex)=>{for(let i=startIndex;i<=endIndex;i++)if(-1===cache._sizes[i])return!0;return!1})(state._cache,startIndex,findEndIndex(state._cache,startIndex,getViewportSize())),_getItemOffset:index=>computeStartOffset(state._cache,index),_getViewportSize:()=>getViewportSize(),_isViewportSizeInitialized:()=>0!==getViewportSize(),_getScrollSize:()=>(cache=>{if(!cache._length)return 0;const lastIndex=cache._length-1;if(cache._measuredOffsetIndex>=lastIndex)return cache._offsets[lastIndex]+getItemSize(cache,lastIndex);let top=cache._offsets[cache._measuredOffsetIndex];for(let i=cache._measuredOffsetIndex;i<=lastIndex;i++)cache._offsets[i]=top,top+=getItemSize(cache,i);return cache._measuredOffsetIndex=lastIndex,top})(state._cache),_getItemCount:()=>state._cache._length,_getJump:()=>state._jump,_waitForScrollDestinationItemsMeasured:()=>(scrollToQueue&&scrollToQueue[1](),new Promise(((resolve,reject)=>{scrollToQueue=[()=>{Promise.resolve().then((()=>{resolve(),scrollToQueue=void 0}))},reject]}))),_subscribe:cb=>(subscribers.add(cb),()=>{subscribers.delete(cb)}),_update(action){mutate(state,action,itemSize)&&(subscribers.forEach((cb=>{cb()})),scrollToQueue&&1===action._type&&scrollToQueue[0]())}}})())},useIsomorphicLayoutEffect="undefined"!=typeof window?react.useLayoutEffect:react.useEffect;var shim=__webpack_require__("./node_modules/use-sync-external-store/shim/index.js");const useSyncExternalStore=(subscibe,getSnapShot)=>(0,shim.useSyncExternalStore)(subscibe,getSnapShot,getSnapShot),Item=(0,react.memo)((({_children:children,_handle:handle,_store:store,_index:index,_element:Element,_isHorizontal:isHorizontal})=>{const ref=(0,react.useRef)(null),offset=useSyncExternalStore(store._subscribe,(()=>store._getItemOffset(index))),hide=useSyncExternalStore(store._subscribe,(()=>store._isUnmeasuredItem(index)));return useIsomorphicLayoutEffect((()=>handle._observe(ref.current,index)),[index]),(0,jsx_runtime.jsx)(Element,{ref,style:(0,react.useMemo)((()=>{const style={margin:"0",padding:"0",position:"absolute",[isHorizontal?"height":"width"]:"100%",[isHorizontal?"top":"left"]:0,[isHorizontal?"left":"top"]:offset};return isHorizontal&&(style.display="flex"),hide&&(style.visibility="hidden"),style}),[offset,isHorizontal,hide]),children})})),isInvalidElement=e=>null==e||"boolean"==typeof e,Window=({_children:children,_ref:ref,_element:Element,_style:style,_isHorizontal:isHorizontal})=>(0,jsx_runtime.jsx)(Element,{ref,style:(0,react.useMemo)((()=>({overflow:isHorizontal?"auto hidden":"hidden auto",position:"relative",contain:"strict",width:"100%",height:"100%",padding:0,margin:0,...style})),[isHorizontal,style]),children}),Inner=({_children:children,_store:store,_element:Element,_style:style,_isHorizontal:isHorizontal})=>{const scrollSize=useSyncExternalStore(store._subscribe,store._getScrollSize),viewportSize=useSyncExternalStore(store._subscribe,store._getViewportSize);return(0,jsx_runtime.jsx)(Element,{style:(0,react.useMemo)((()=>{const clampedScrollSize=scrollSize>=viewportSize?scrollSize:viewportSize,width=isHorizontal?clampedScrollSize:"100%",height=isHorizontal?"100%":clampedScrollSize;return{position:"absolute",top:0,left:0,width,height,minWidth:width,minHeight:height,...style}}),[scrollSize,viewportSize,style,isHorizontal]),children})},List=(0,react.forwardRef)((({children,itemSize=40,overscan=6,horizontal:isHorizontal,endThreshold=0,style:styleProp,innerStyle:innerStyleProp,element="div",innerElement="div",itemElement="div",onEndReached},ref)=>{const scrollToKey=isHorizontal?"scrollLeft":"scrollTop",rawCount=(0,react.useMemo)((()=>{let i=0;return react.Children.forEach(children,(e=>{isInvalidElement(e)||i++})),i}),[children]),store=useVirtualStore(rawCount,itemSize,isHorizontal),startIndex=useSyncExternalStore(store._subscribe,store._getStartIndex),endIndex=useSyncExternalStore(store._subscribe,store._getEndIndex),isViewportInitialized=useSyncExternalStore(store._subscribe,store._isViewportSizeInitialized),jump=useSyncExternalStore(store._subscribe,store._getJump),scrollRef=(0,react.useRef)(null),onEndReachedCalledIndex=(0,react.useRef)(-1),handleRef=(0,react.useRef)(),handle=handleRef.current||(handleRef.current=(()=>{let ro,prevOffset=-1,scrollDirection=0,resized=!1;const mountedIndexes=new WeakMap;return{_init(root){const syncViewportToScrollPosition=()=>{const offset=root[scrollToKey];prevOffset!==offset&&(0!==scrollDirection&&resized?resized=!1:3!==scrollDirection&&(scrollDirection=prevOffset>offset?2:1),store._update({_type:3,_offset:prevOffset=offset}))},onScrollStopped=((fn,ms)=>{let id=null;const cancel=()=>{null!=id&&clearTimeout(id)},debouncedFn=()=>{cancel(),id=setTimeout((()=>{id=null,fn()}),ms)};return debouncedFn._cancel=cancel,debouncedFn})((()=>{syncViewportToScrollPosition(),scrollDirection=0}),300),onScroll=()=>{syncViewportToScrollPosition(),onScrollStopped()};return ro=new ResizeObserver((entries=>{const resizes=[];for(const entry of entries)if(entry.target===root)store._update({_type:2,_width:entry.contentRect.width,_height:entry.contentRect.height});else{const index=mountedIndexes.get(entry.target);null!=index&&resizes.push([index,entry.contentRect[isHorizontal?"width":"height"]])}resizes.length&&(store._update({_type:1,_entries:resizes}),resized=!0)})),ro.observe(root),root.addEventListener("scroll",onScroll),()=>{ro.disconnect(),root.removeEventListener("scroll",onScroll),onScrollStopped._cancel()}},_observe:(el,i)=>(mountedIndexes.set(el,i),ro.observe(el),()=>{mountedIndexes.delete(el),ro.unobserve(el)}),_getScrollDirection:()=>scrollDirection,_startManuallScroll(){scrollDirection=3}}})()),count=min(rawCount,store._getItemCount()),startIndexWithMargin=max(startIndex-overscan,0),endIndexWithMargin=min(endIndex+overscan,count-1);useIsomorphicLayoutEffect((()=>{store._update({_type:0,_length:rawCount})}),[rawCount]),useIsomorphicLayoutEffect((()=>handle._init(scrollRef.current)),[]),useIsomorphicLayoutEffect((()=>{if(!scrollRef.current||!jump.length)return;const scrollDirection=handle._getScrollDirection();if(2===scrollDirection){const diff=jump.reduce(((acc,[,j])=>acc+j),0);diff&&(scrollRef.current[scrollToKey]+=diff)}else if(3===scrollDirection){const isStartInView=0===startIndex,isEndInView=endIndex-(count-1)==0,diff=jump.reduce(((acc,[index,j])=>(index<startIndex?isStartInView||(acc+=j):!isStartInView&&isEndInView&&(acc+=j),acc)),0);diff&&(scrollRef.current[scrollToKey]+=diff)}}),[jump]),(0,react.useEffect)((()=>{if(!onEndReached)return;onEndReachedCalledIndex.current>count&&(onEndReachedCalledIndex.current=-1);count-1-endIndex<=endThreshold&&onEndReachedCalledIndex.current<count&&(onEndReachedCalledIndex.current=count,onEndReached())}),[endIndex]),(0,react.useImperativeHandle)(ref,(()=>({scrollToIndex:async index=>{const el=scrollRef.current;if(!el)return;index=max(min(index,count-1),0);const getScrollDestination=()=>{let offset=store._getItemOffset(index);const scrollSize=isHorizontal?el.scrollWidth:el.scrollHeight,viewportSize=store._getViewportSize();return scrollSize-(offset+viewportSize)<=0&&(offset=scrollSize-viewportSize),offset};if(store._hasUnmeasuredItemsInRange(index)){do{store._update({_type:3,_offset:getScrollDestination()});try{await store._waitForScrollDestinationItemsMeasured()}catch(e){return}}while(store._hasUnmeasuredItemsInRange(index));el[scrollToKey]=getScrollDestination()}else{const offset=getScrollDestination();el[scrollToKey]=offset,store._update({_type:3,_offset:offset})}handle._startManuallScroll()}})),[count]);const items=(0,react.useMemo)((()=>{let i=-1;return react.Children.map(children,(e=>{if(!(isInvalidElement(e)||(i++,i<startIndexWithMargin||i>endIndexWithMargin)))return null!=e?(0,jsx_runtime.jsx)(Item,{_handle:handle,_store:store,_index:i,_element:itemElement,_isHorizontal:isHorizontal,_children:e},(null==e?void 0:e.key)||i):null}))}),[children,startIndexWithMargin,endIndexWithMargin]);return(0,jsx_runtime.jsx)(Window,{_ref:scrollRef,_isHorizontal:isHorizontal,_element:element,_style:styleProp,_children:(0,jsx_runtime.jsx)(Inner,{_store:store,_element:innerElement,_style:innerStyleProp,_isHorizontal:isHorizontal,_children:isViewportInitialized&&items})})}));try{List.displayName="List",List.__docgenInfo={description:"Virtualized list component. See {@link ListProps} and {@link ListHandle}.",displayName:"List",props:{children:{defaultValue:null,description:"Elements rendered by this component.",name:"children",required:!0,type:{name:"ReactNode"}},itemSize:{defaultValue:{value:"40"},description:"Item size hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.\n@defaultValue 40",name:"itemSize",required:!1,type:{name:"number"}},overscan:{defaultValue:{value:"6"},description:"Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n@defaultValue 6",name:"overscan",required:!1,type:{name:"number"}},horizontal:{defaultValue:null,description:"If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.",name:"horizontal",required:!1,type:{name:"boolean"}},endThreshold:{defaultValue:{value:"0"},description:"Number of items to be the margin from the end of the scroll. See also {@link onEndReached}.\n@defaultValue 0",name:"endThreshold",required:!1,type:{name:"number"}},style:{defaultValue:null,description:"Inline style prop to override style of scrollable element.",name:"style",required:!1,type:{name:"CSSProperties"}},innerStyle:{defaultValue:null,description:"Inline style prop to override style of inner element.",name:"innerStyle",required:!1,type:{name:"CSSProperties"}},element:{defaultValue:{value:"div"},description:'Customized element type for scrollable element.\n@defaultValue "div"',name:"element",required:!1,type:{name:"CustomElementType"}},innerElement:{defaultValue:{value:"div"},description:'Customized element type for inner element.\n@defaultValue "div"',name:"innerElement",required:!1,type:{name:"CustomElementType"}},itemElement:{defaultValue:{value:"div"},description:'Customized element type for item element.\n@defaultValue "div"',name:"itemElement",required:!1,type:{name:"CustomElementType"}},onEndReached:{defaultValue:null,description:"Callback invoked when scrolling reached to the end. The margin from the end is specified by {@link endThreshold}.",name:"onEndReached",required:!1,type:{name:"() => void"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/List.tsx#List"]={docgenInfo:List.__docgenInfo,name:"List",path:"src/List.tsx#List"})}catch(__react_docgen_typescript_loader_error){}},"./stories/advanced/Zoomable.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Default:()=>Default,default:()=>__WEBPACK_DEFAULT_EXPORT__});var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/jsx-runtime.js"),_src__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./src/List.tsx"),react__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react/index.js");const __WEBPACK_DEFAULT_EXPORT__={component:_src__WEBPACK_IMPORTED_MODULE_2__.a},Default={name:"Zoomable",render:()=>{const[zoom,setZoom]=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div",{style:{height:600},children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div",{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label",{style:{width:"100%"},children:["zoom x",zoom,(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input",{type:"range",value:zoom,min:1,max:10,step:.01,style:{width:"85%"},onChange:e=>{setZoom(Number(e.target.value))}})]})}),(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div",{style:{overflow:"hidden"},children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_src__WEBPACK_IMPORTED_MODULE_2__.a,{style:{height:"100vh"},children:Array.from({length:1e3}).map(((_,i)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div",{style:{height:40,background:"#fff",borderBottom:"solid 1px #ccc",zoom,transformOrigin:"center top"},children:i},i)))})})]})}};Default.parameters={...Default.parameters,docs:{...Default.parameters?.docs,source:{originalSource:'{\n  name: "Zoomable",\n  render: () => {\n    const [zoom, setZoom] = useState(1);\n    return /* @__PURE__ */jsxs("div", {\n      style: {\n        height: 600\n      },\n      children: [/* @__PURE__ */jsx("div", {\n        children: /* @__PURE__ */jsxs("label", {\n          style: {\n            width: "100%"\n          },\n          children: ["zoom x", zoom, /* @__PURE__ */jsx("input", {\n            type: "range",\n            value: zoom,\n            min: 1,\n            max: 10,\n            step: 0.01,\n            style: {\n              width: "85%"\n            },\n            onChange: e => {\n              setZoom(Number(e.target.value));\n            }\n          })]\n        })\n      }), /* @__PURE__ */jsx("div", {\n        style: {\n          overflow: "hidden"\n        },\n        children: /* @__PURE__ */jsx(List, {\n          style: {\n            height: "100vh"\n          },\n          children: Array.from({\n            length: 1e3\n          }).map((_, i) => {\n            return /* @__PURE__ */jsx("div", {\n              style: {\n                height: 40,\n                background: "#fff",\n                borderBottom: "solid 1px #ccc",\n                zoom,\n                transformOrigin: "center top"\n              },\n              children: i\n            }, i);\n          })\n        })\n      })]\n    });\n  }\n}',...Default.parameters?.docs?.source}}}}}]);